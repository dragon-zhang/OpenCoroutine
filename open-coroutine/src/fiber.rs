/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _LIBCPP_VERSION: u32 = 13000;
pub const _LIBCPP_ABI_VERSION: u32 = 1;
pub const _LIBCPP_STD_VER: u32 = 11;
pub const _LIBCPP_OBJECT_FORMAT_MACHO: u32 = 1;
pub const _LIBCPP_HIDE_FROM_ABI_PER_TU: u32 = 1;
pub const _LIBCPP_DEBUG_LEVEL: u32 = 0;
pub const _LIBCPP_LOCALE__L_EXTENSIONS: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 120300;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const KEV_INET_SUBCLASS: u32 = 1;
pub const KEV_INET_NEW_ADDR: u32 = 1;
pub const KEV_INET_CHANGED_ADDR: u32 = 2;
pub const KEV_INET_ADDR_DELETED: u32 = 3;
pub const KEV_INET_SIFDSTADDR: u32 = 4;
pub const KEV_INET_SIFBRDADDR: u32 = 5;
pub const KEV_INET_SIFNETMASK: u32 = 6;
pub const KEV_INET_ARPCOLLISION: u32 = 7;
pub const KEV_INET_PORTINUSE: u32 = 8;
pub const KEV_INET_ARPRTRFAILURE: u32 = 9;
pub const KEV_INET_ARPRTRALIVE: u32 = 10;
pub const KEV_DL_SUBCLASS: u32 = 2;
pub const KEV_DL_SIFFLAGS: u32 = 1;
pub const KEV_DL_SIFMETRICS: u32 = 2;
pub const KEV_DL_SIFMTU: u32 = 3;
pub const KEV_DL_SIFPHYS: u32 = 4;
pub const KEV_DL_SIFMEDIA: u32 = 5;
pub const KEV_DL_SIFGENERIC: u32 = 6;
pub const KEV_DL_ADDMULTI: u32 = 7;
pub const KEV_DL_DELMULTI: u32 = 8;
pub const KEV_DL_IF_ATTACHED: u32 = 9;
pub const KEV_DL_IF_DETACHING: u32 = 10;
pub const KEV_DL_IF_DETACHED: u32 = 11;
pub const KEV_DL_LINK_OFF: u32 = 12;
pub const KEV_DL_LINK_ON: u32 = 13;
pub const KEV_DL_PROTO_ATTACHED: u32 = 14;
pub const KEV_DL_PROTO_DETACHED: u32 = 15;
pub const KEV_DL_LINK_ADDRESS_CHANGED: u32 = 16;
pub const KEV_DL_WAKEFLAGS_CHANGED: u32 = 17;
pub const KEV_DL_IF_IDLE_ROUTE_REFCNT: u32 = 18;
pub const KEV_DL_IFCAP_CHANGED: u32 = 19;
pub const KEV_DL_LINK_QUALITY_METRIC_CHANGED: u32 = 20;
pub const KEV_DL_NODE_PRESENCE: u32 = 21;
pub const KEV_DL_NODE_ABSENCE: u32 = 22;
pub const KEV_DL_PRIMARY_ELECTED: u32 = 23;
pub const KEV_DL_ISSUES: u32 = 24;
pub const KEV_DL_IFDELEGATE_CHANGED: u32 = 25;
pub const KEV_DL_AWDL_RESTRICTED: u32 = 26;
pub const KEV_DL_AWDL_UNRESTRICTED: u32 = 27;
pub const KEV_DL_RRC_STATE_CHANGED: u32 = 28;
pub const KEV_DL_QOS_MODE_CHANGED: u32 = 29;
pub const KEV_DL_LOW_POWER_MODE_CHANGED: u32 = 30;
pub const KEV_INET6_SUBCLASS: u32 = 6;
pub const KEV_INET6_NEW_USER_ADDR: u32 = 1;
pub const KEV_INET6_CHANGED_ADDR: u32 = 2;
pub const KEV_INET6_ADDR_DELETED: u32 = 3;
pub const KEV_INET6_NEW_LL_ADDR: u32 = 4;
pub const KEV_INET6_NEW_RTADV_ADDR: u32 = 5;
pub const KEV_INET6_DEFROUTER: u32 = 6;
pub const KEV_INET6_REQUEST_NAT64_PREFIX: u32 = 7;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SOCK_RDM: u32 = 4;
pub const SOCK_SEQPACKET: u32 = 5;
pub const SO_DEBUG: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_BROADCAST: u32 = 32;
pub const SO_USELOOPBACK: u32 = 64;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_REUSEPORT: u32 = 512;
pub const SO_TIMESTAMP: u32 = 1024;
pub const SO_TIMESTAMP_MONOTONIC: u32 = 2048;
pub const SO_DONTTRUNC: u32 = 8192;
pub const SO_WANTMORE: u32 = 16384;
pub const SO_WANTOOBFLAG: u32 = 32768;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_SNDTIMEO: u32 = 4101;
pub const SO_RCVTIMEO: u32 = 4102;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_LABEL: u32 = 4112;
pub const SO_PEERLABEL: u32 = 4113;
pub const SO_NREAD: u32 = 4128;
pub const SO_NKE: u32 = 4129;
pub const SO_NOSIGPIPE: u32 = 4130;
pub const SO_NOADDRERR: u32 = 4131;
pub const SO_NWRITE: u32 = 4132;
pub const SO_REUSESHAREUID: u32 = 4133;
pub const SO_NOTIFYCONFLICT: u32 = 4134;
pub const SO_UPCALLCLOSEWAIT: u32 = 4135;
pub const SO_LINGER_SEC: u32 = 4224;
pub const SO_RANDOMPORT: u32 = 4226;
pub const SO_NP_EXTENSIONS: u32 = 4227;
pub const SO_NUMRCVPKT: u32 = 4370;
pub const SO_NET_SERVICE_TYPE: u32 = 4374;
pub const SO_NETSVC_MARKING_LEVEL: u32 = 4377;
pub const NET_SERVICE_TYPE_BE: u32 = 0;
pub const NET_SERVICE_TYPE_BK: u32 = 1;
pub const NET_SERVICE_TYPE_SIG: u32 = 2;
pub const NET_SERVICE_TYPE_VI: u32 = 3;
pub const NET_SERVICE_TYPE_VO: u32 = 4;
pub const NET_SERVICE_TYPE_RV: u32 = 5;
pub const NET_SERVICE_TYPE_AV: u32 = 6;
pub const NET_SERVICE_TYPE_OAM: u32 = 7;
pub const NET_SERVICE_TYPE_RD: u32 = 8;
pub const NETSVC_MRKNG_UNKNOWN: u32 = 0;
pub const NETSVC_MRKNG_LVL_L2: u32 = 1;
pub const NETSVC_MRKNG_LVL_L3L2_ALL: u32 = 2;
pub const NETSVC_MRKNG_LVL_L3L2_BK: u32 = 3;
pub const SAE_ASSOCID_ANY: u32 = 0;
pub const SAE_CONNID_ANY: u32 = 0;
pub const CONNECT_RESUME_ON_READ_WRITE: u32 = 1;
pub const CONNECT_DATA_IDEMPOTENT: u32 = 2;
pub const CONNECT_DATA_AUTHENTICATED: u32 = 4;
pub const SONPX_SETOPTSHUT: u32 = 1;
pub const SOL_SOCKET: u32 = 65535;
pub const AF_UNSPEC: u32 = 0;
pub const AF_UNIX: u32 = 1;
pub const AF_LOCAL: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_IMPLINK: u32 = 3;
pub const AF_PUP: u32 = 4;
pub const AF_CHAOS: u32 = 5;
pub const AF_NS: u32 = 6;
pub const AF_ISO: u32 = 7;
pub const AF_OSI: u32 = 7;
pub const AF_ECMA: u32 = 8;
pub const AF_DATAKIT: u32 = 9;
pub const AF_CCITT: u32 = 10;
pub const AF_SNA: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_DLI: u32 = 13;
pub const AF_LAT: u32 = 14;
pub const AF_HYLINK: u32 = 15;
pub const AF_APPLETALK: u32 = 16;
pub const AF_ROUTE: u32 = 17;
pub const AF_LINK: u32 = 18;
pub const pseudo_AF_XTP: u32 = 19;
pub const AF_COIP: u32 = 20;
pub const AF_CNT: u32 = 21;
pub const pseudo_AF_RTIP: u32 = 22;
pub const AF_IPX: u32 = 23;
pub const AF_SIP: u32 = 24;
pub const pseudo_AF_PIP: u32 = 25;
pub const AF_NDRV: u32 = 27;
pub const AF_ISDN: u32 = 28;
pub const AF_E164: u32 = 28;
pub const pseudo_AF_KEY: u32 = 29;
pub const AF_INET6: u32 = 30;
pub const AF_NATM: u32 = 31;
pub const AF_SYSTEM: u32 = 32;
pub const AF_NETBIOS: u32 = 33;
pub const AF_PPP: u32 = 34;
pub const pseudo_AF_HDRCMPLT: u32 = 35;
pub const AF_RESERVED_36: u32 = 36;
pub const AF_IEEE80211: u32 = 37;
pub const AF_UTUN: u32 = 38;
pub const AF_VSOCK: u32 = 40;
pub const AF_MAX: u32 = 41;
pub const SOCK_MAXADDRLEN: u32 = 255;
pub const _SS_MAXSIZE: u32 = 128;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_IMPLINK: u32 = 3;
pub const PF_PUP: u32 = 4;
pub const PF_CHAOS: u32 = 5;
pub const PF_NS: u32 = 6;
pub const PF_ISO: u32 = 7;
pub const PF_OSI: u32 = 7;
pub const PF_ECMA: u32 = 8;
pub const PF_DATAKIT: u32 = 9;
pub const PF_CCITT: u32 = 10;
pub const PF_SNA: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_DLI: u32 = 13;
pub const PF_LAT: u32 = 14;
pub const PF_HYLINK: u32 = 15;
pub const PF_APPLETALK: u32 = 16;
pub const PF_ROUTE: u32 = 17;
pub const PF_LINK: u32 = 18;
pub const PF_XTP: u32 = 19;
pub const PF_COIP: u32 = 20;
pub const PF_CNT: u32 = 21;
pub const PF_SIP: u32 = 24;
pub const PF_IPX: u32 = 23;
pub const PF_RTIP: u32 = 22;
pub const PF_PIP: u32 = 25;
pub const PF_NDRV: u32 = 27;
pub const PF_ISDN: u32 = 28;
pub const PF_KEY: u32 = 29;
pub const PF_INET6: u32 = 30;
pub const PF_NATM: u32 = 31;
pub const PF_SYSTEM: u32 = 32;
pub const PF_NETBIOS: u32 = 33;
pub const PF_PPP: u32 = 34;
pub const PF_RESERVED_36: u32 = 36;
pub const PF_UTUN: u32 = 38;
pub const PF_VSOCK: u32 = 40;
pub const PF_MAX: u32 = 41;
pub const NET_MAXID: u32 = 41;
pub const NET_RT_DUMP: u32 = 1;
pub const NET_RT_FLAGS: u32 = 2;
pub const NET_RT_IFLIST: u32 = 3;
pub const NET_RT_STAT: u32 = 4;
pub const NET_RT_TRASH: u32 = 5;
pub const NET_RT_IFLIST2: u32 = 6;
pub const NET_RT_DUMP2: u32 = 7;
pub const NET_RT_FLAGS_PRIV: u32 = 10;
pub const NET_RT_MAXID: u32 = 11;
pub const SOMAXCONN: u32 = 128;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_EOR: u32 = 8;
pub const MSG_TRUNC: u32 = 16;
pub const MSG_CTRUNC: u32 = 32;
pub const MSG_WAITALL: u32 = 64;
pub const MSG_DONTWAIT: u32 = 128;
pub const MSG_EOF: u32 = 256;
pub const MSG_WAITSTREAM: u32 = 512;
pub const MSG_FLUSH: u32 = 1024;
pub const MSG_HOLD: u32 = 2048;
pub const MSG_SEND: u32 = 4096;
pub const MSG_HAVEMORE: u32 = 8192;
pub const MSG_RCVMORE: u32 = 16384;
pub const MSG_NEEDSA: u32 = 65536;
pub const MSG_NOSIGNAL: u32 = 524288;
pub const SCM_RIGHTS: u32 = 1;
pub const SCM_TIMESTAMP: u32 = 2;
pub const SCM_CREDS: u32 = 3;
pub const SCM_TIMESTAMP_MONOTONIC: u32 = 4;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __GNUC_VA_LIST: u32 = 1;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const TIME_UTC: u32 = 1;
pub const _CACHED_RUNES: u32 = 256;
pub const _CRMASK: i32 = -256;
pub const _RUNE_MAGIC_A: &[u8; 9usize] = b"RuneMagA\0";
pub const _CTYPE_A: u32 = 256;
pub const _CTYPE_C: u32 = 512;
pub const _CTYPE_D: u32 = 1024;
pub const _CTYPE_G: u32 = 2048;
pub const _CTYPE_L: u32 = 4096;
pub const _CTYPE_P: u32 = 8192;
pub const _CTYPE_S: u32 = 16384;
pub const _CTYPE_U: u32 = 32768;
pub const _CTYPE_X: u32 = 65536;
pub const _CTYPE_B: u32 = 131072;
pub const _CTYPE_R: u32 = 262144;
pub const _CTYPE_I: u32 = 524288;
pub const _CTYPE_T: u32 = 1048576;
pub const _CTYPE_Q: u32 = 2097152;
pub const _CTYPE_SW0: u32 = 536870912;
pub const _CTYPE_SW1: u32 = 1073741824;
pub const _CTYPE_SW2: u32 = 2147483648;
pub const _CTYPE_SW3: u32 = 3221225472;
pub const _CTYPE_SWM: u32 = 3758096384;
pub const _CTYPE_SWS: u32 = 30;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_CURRENT: u32 = 5;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const _LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION: u32 = 3;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EDEADLK: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EAGAIN: u32 = 35;
pub const EWOULDBLOCK: u32 = 35;
pub const EINPROGRESS: u32 = 36;
pub const EALREADY: u32 = 37;
pub const ENOTSOCK: u32 = 38;
pub const EDESTADDRREQ: u32 = 39;
pub const EMSGSIZE: u32 = 40;
pub const EPROTOTYPE: u32 = 41;
pub const ENOPROTOOPT: u32 = 42;
pub const EPROTONOSUPPORT: u32 = 43;
pub const ESOCKTNOSUPPORT: u32 = 44;
pub const ENOTSUP: u32 = 45;
pub const EPFNOSUPPORT: u32 = 46;
pub const EAFNOSUPPORT: u32 = 47;
pub const EADDRINUSE: u32 = 48;
pub const EADDRNOTAVAIL: u32 = 49;
pub const ENETDOWN: u32 = 50;
pub const ENETUNREACH: u32 = 51;
pub const ENETRESET: u32 = 52;
pub const ECONNABORTED: u32 = 53;
pub const ECONNRESET: u32 = 54;
pub const ENOBUFS: u32 = 55;
pub const EISCONN: u32 = 56;
pub const ENOTCONN: u32 = 57;
pub const ESHUTDOWN: u32 = 58;
pub const ETOOMANYREFS: u32 = 59;
pub const ETIMEDOUT: u32 = 60;
pub const ECONNREFUSED: u32 = 61;
pub const ELOOP: u32 = 62;
pub const ENAMETOOLONG: u32 = 63;
pub const EHOSTDOWN: u32 = 64;
pub const EHOSTUNREACH: u32 = 65;
pub const ENOTEMPTY: u32 = 66;
pub const EPROCLIM: u32 = 67;
pub const EUSERS: u32 = 68;
pub const EDQUOT: u32 = 69;
pub const ESTALE: u32 = 70;
pub const EREMOTE: u32 = 71;
pub const EBADRPC: u32 = 72;
pub const ERPCMISMATCH: u32 = 73;
pub const EPROGUNAVAIL: u32 = 74;
pub const EPROGMISMATCH: u32 = 75;
pub const EPROCUNAVAIL: u32 = 76;
pub const ENOLCK: u32 = 77;
pub const ENOSYS: u32 = 78;
pub const EFTYPE: u32 = 79;
pub const EAUTH: u32 = 80;
pub const ENEEDAUTH: u32 = 81;
pub const EPWROFF: u32 = 82;
pub const EDEVERR: u32 = 83;
pub const EOVERFLOW: u32 = 84;
pub const EBADEXEC: u32 = 85;
pub const EBADARCH: u32 = 86;
pub const ESHLIBVERS: u32 = 87;
pub const EBADMACHO: u32 = 88;
pub const ECANCELED: u32 = 89;
pub const EIDRM: u32 = 90;
pub const ENOMSG: u32 = 91;
pub const EILSEQ: u32 = 92;
pub const ENOATTR: u32 = 93;
pub const EBADMSG: u32 = 94;
pub const EMULTIHOP: u32 = 95;
pub const ENODATA: u32 = 96;
pub const ENOLINK: u32 = 97;
pub const ENOSR: u32 = 98;
pub const ENOSTR: u32 = 99;
pub const EPROTO: u32 = 100;
pub const ETIME: u32 = 101;
pub const EOPNOTSUPP: u32 = 102;
pub const ENOPOLICY: u32 = 103;
pub const ENOTRECOVERABLE: u32 = 104;
pub const EOWNERDEAD: u32 = 105;
pub const EQFULL: u32 = 106;
pub const ELAST: u32 = 106;
pub const _PTHREAD_MUTEX_SIG_init: u32 = 850045863;
pub const _PTHREAD_ERRORCHECK_MUTEX_SIG_init: u32 = 850045857;
pub const _PTHREAD_RECURSIVE_MUTEX_SIG_init: u32 = 850045858;
pub const _PTHREAD_FIRSTFIT_MUTEX_SIG_init: u32 = 850045859;
pub const _PTHREAD_COND_SIG_init: u32 = 1018212795;
pub const _PTHREAD_ONCE_SIG_init: u32 = 816954554;
pub const _PTHREAD_RWLOCK_SIG_init: u32 = 766030772;
pub const SCHED_OTHER: u32 = 1;
pub const SCHED_FIFO: u32 = 4;
pub const SCHED_RR: u32 = 2;
pub const __SCHED_PARAM_SIZE__: u32 = 4;
pub const QOS_MIN_RELATIVE_PRIORITY: i32 = -15;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_CREATE_DETACHED: u32 = 2;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CANCEL_ENABLE: u32 = 1;
pub const PTHREAD_CANCEL_DISABLE: u32 = 0;
pub const PTHREAD_CANCEL_DEFERRED: u32 = 2;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_SCOPE_PROCESS: u32 = 2;
pub const PTHREAD_PROCESS_SHARED: u32 = 1;
pub const PTHREAD_PROCESS_PRIVATE: u32 = 2;
pub const PTHREAD_PRIO_NONE: u32 = 0;
pub const PTHREAD_PRIO_INHERIT: u32 = 1;
pub const PTHREAD_PRIO_PROTECT: u32 = 2;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 1;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 0;
pub const PTHREAD_MUTEX_POLICY_FAIRSHARE_NP: u32 = 1;
pub const PTHREAD_MUTEX_POLICY_FIRSTFIT_NP: u32 = 3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_nullptr_t {
    pub __lx: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_nullptr_t___nat {
    pub __for_bool_: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_std_nullptr_t___nat() {
    assert_eq!(
        ::std::mem::size_of::<std_nullptr_t___nat>(),
        4usize,
        concat!("Size of: ", stringify!(std_nullptr_t___nat))
    );
    assert_eq!(
        ::std::mem::align_of::<std_nullptr_t___nat>(),
        4usize,
        concat!("Alignment of ", stringify!(std_nullptr_t___nat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_nullptr_t___nat>())).__for_bool_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_nullptr_t___nat),
            "::",
            stringify!(__for_bool_)
        )
    );
}
#[test]
fn bindgen_test_layout_std_nullptr_t() {
    assert_eq!(
        ::std::mem::size_of::<std_nullptr_t>(),
        8usize,
        concat!("Size of: ", stringify!(std_nullptr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_nullptr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(std_nullptr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_nullptr_t>())).__lx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_nullptr_t),
            "::",
            stringify!(__lx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ios_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ios {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_streambuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ostream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_iostream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_stringbuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istringstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ostringstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_stringstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_filebuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ifstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ofstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_fstream {
    pub _address: u8,
}
pub type std_ios = std_basic_ios;
pub type std_wios = std_basic_ios;
pub type std_streambuf = std_basic_streambuf;
pub type std_istream = std_basic_istream;
pub type std_ostream = std_basic_ostream;
pub type std_iostream = std_basic_iostream;
pub type std_stringbuf = std_basic_stringbuf;
pub type std_istringstream = std_basic_istringstream;
pub type std_ostringstream = std_basic_ostringstream;
pub type std_stringstream = std_basic_stringstream;
pub type std_filebuf = std_basic_filebuf;
pub type std_ifstream = std_basic_ifstream;
pub type std_ofstream = std_basic_ofstream;
pub type std_fstream = std_basic_fstream;
pub type std_wstreambuf = std_basic_streambuf;
pub type std_wistream = std_basic_istream;
pub type std_wostream = std_basic_ostream;
pub type std_wiostream = std_basic_iostream;
pub type std_wstringbuf = std_basic_stringbuf;
pub type std_wistringstream = std_basic_istringstream;
pub type std_wostringstream = std_basic_ostringstream;
pub type std_wstringstream = std_basic_stringstream;
pub type std_wfilebuf = std_basic_filebuf;
pub type std_wifstream = std_basic_ifstream;
pub type std_wofstream = std_basic_ofstream;
pub type std_wfstream = std_basic_fstream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_fpos {
    pub _address: u8,
}
pub type std_streampos = std_fpos;
pub type std_wstreampos = std_fpos;
pub type std_u16streampos = std_fpos;
pub type std_u32streampos = std_fpos;
pub type std_streamoff = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string {
    pub _address: u8,
}
pub type std_string = std_basic_string;
pub type std_wstring = std_basic_string;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std___save_flags<_CharT> {
    pub __stream_: *mut std___save_flags___stream_type,
    pub __fmtflags_: std___save_flags_fmtflags,
    pub __fill_: _CharT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std___save_flags___stream_type = std_basic_ios;
pub type std___save_flags_fmtflags = std___save_flags___stream_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_is_integral {
    pub _address: u8,
}
pub const std___libcpp_is_integral_value: i32 = 0;
pub type std___libcpp_is_integral__bindgen_ty_1 = i32;
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_debug_info {
    pub __file_: *const ::std::os::raw::c_char,
    pub __line_: ::std::os::raw::c_int,
    pub __pred_: *const ::std::os::raw::c_char,
    pub __msg_: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_std___libcpp_debug_info() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_debug_info>(),
        32usize,
        concat!("Size of: ", stringify!(std___libcpp_debug_info))
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_debug_info>(),
        8usize,
        concat!("Alignment of ", stringify!(std___libcpp_debug_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std___libcpp_debug_info>())).__file_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___libcpp_debug_info),
            "::",
            stringify!(__file_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std___libcpp_debug_info>())).__line_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std___libcpp_debug_info),
            "::",
            stringify!(__line_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std___libcpp_debug_info>())).__pred_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std___libcpp_debug_info),
            "::",
            stringify!(__pred_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std___libcpp_debug_info>())).__msg_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(std___libcpp_debug_info),
            "::",
            stringify!(__msg_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt3__119__libcpp_debug_info4whatEv"]
    pub fn std___libcpp_debug_info_what(this: *const std___libcpp_debug_info) -> std_string;
}
impl std___libcpp_debug_info {
    #[inline]
    pub unsafe fn what(&self) -> std_string {
        std___libcpp_debug_info_what(self)
    }
}
pub type std___libcpp_debug_function_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const std___libcpp_debug_info)>;
extern "C" {
    #[link_name = "\u{1}__ZNSt3__123__libcpp_debug_functionE"]
    pub static mut std___libcpp_debug_function: std___libcpp_debug_function_type;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__129__libcpp_abort_debug_functionERKNS_19__libcpp_debug_infoE"]
    pub fn std___libcpp_abort_debug_function(arg1: *const std___libcpp_debug_info);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__127__libcpp_set_debug_functionEPFvRKNS_19__libcpp_debug_infoEE"]
    pub fn std___libcpp_set_debug_function(__func: std___libcpp_debug_function_type) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_hash {
    pub _address: u8,
}
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std_false_type = u8;
pub type std__BoolConstant = u8;
pub type std__EnableIf = u8;
pub type std__If = u8;
pub type std__Or = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Not {
    pub _address: u8,
}
pub type std__FirstType = u8;
pub type std__SecondType = u8;
pub type std___expand_to_true = std_true_type;
pub type std__And<_Pred> = _Pred;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Lazy {
    pub _address: u8,
}
pub type std__IsValidExpansion = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___void_t {
    pub _address: u8,
}
pub type std___void_t_type = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___identity {
    pub _address: u8,
}
pub type std___identity_type<_Tp> = _Tp;
pub type std___identity_t = std___identity;
pub type std_conditional_type<_If> = _If;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_same {
    pub _address: u8,
}
pub type std__IsSame = std__BoolConstant;
pub type std__IsNotSame = std__BoolConstant;
pub type std___test_for_primary_template = std__EnableIf;
pub type std___is_primary_template = std__IsValidExpansion;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___two {
    pub __lx: [::std::os::raw::c_char; 2usize],
}
#[test]
fn bindgen_test_layout_std___two() {
    assert_eq!(
        ::std::mem::size_of::<std___two>(),
        2usize,
        concat!("Size of: ", stringify!(std___two))
    );
    assert_eq!(
        ::std::mem::align_of::<std___two>(),
        1usize,
        concat!("Alignment of ", stringify!(std___two))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std___two>())).__lx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___two),
            "::",
            stringify!(__lx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_const {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_volatile {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_const {
    pub _address: u8,
}
pub type std_remove_const_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_volatile {
    pub _address: u8,
}
pub type std_remove_volatile_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_cv {
    pub _address: u8,
}
pub type std_remove_cv_type = std_remove_volatile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_void {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nullptr_t_impl {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___is_nullptr_t_impl_open0_std_nullptr_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_nullptr_t_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_nullptr_t_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_nullptr_t_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_nullptr_t_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nullptr_t {
    pub _base: std___is_nullptr_t_impl,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_integral {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_is_signed_integer {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_signed_integer_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_signed_integer_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_signed_integer_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_signed_integer_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_signed_integer_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_signed_integer_open0___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_signed_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_signed_integer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_is_unsigned_integer {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_unsigned_integer_open0_unsigned_char_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_unsigned_integer_open0_unsigned_short_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_unsigned_integer_open0_unsigned_int_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_unsigned_integer_open0_unsigned_long_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_unsigned_integer_open0_unsigned_long_long_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_unsigned_integer_open0_unsigned___int128_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_unsigned_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_unsigned_integer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_is_floating_point {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_floating_point_open0_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_floating_point>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_floating_point)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_floating_point>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_floating_point)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_floating_point_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_floating_point>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_floating_point)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_floating_point>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_floating_point)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_floating_point_open0_long_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_floating_point>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_floating_point)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_floating_point>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_floating_point)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_floating_point {
    pub _base: std___libcpp_is_floating_point,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_array {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_lvalue_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_rvalue_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_union {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_is_member_pointer {
    pub _address: u8,
}
pub const std___libcpp_is_member_pointer___is_member: i32 = 0;
pub const std___libcpp_is_member_pointer___is_func: i32 = 0;
pub const std___libcpp_is_member_pointer___is_obj: i32 = 0;
pub type std___libcpp_is_member_pointer__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_function_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_object_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_enum {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_fundamental {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_block {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_scalar {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_is_scalar_open0_std_nullptr_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_scalar>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_is_scalar)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_scalar>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_scalar)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_object {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_compound {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_referenceable_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___is_referenceable_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___is_referenceable_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___is_referenceable_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_referenceable_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___is_referenceable_impl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_referenceable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_const {
    pub _address: u8,
}
pub type std_add_const_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_volatile {
    pub _address: u8,
}
pub type std_add_volatile_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_cv {
    pub _address: u8,
}
pub type std_add_cv_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_reference {
    pub _address: u8,
}
pub type std_remove_reference_type<_Tp> = _Tp;
pub type std___add_lvalue_reference_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_lvalue_reference {
    pub _address: u8,
}
pub type std_add_lvalue_reference_type = u8;
pub type std___add_rvalue_reference_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_rvalue_reference {
    pub _address: u8,
}
pub type std_add_rvalue_reference_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uncvref {
    pub _address: u8,
}
pub type std___uncvref_type = std_remove_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___unconstref {
    pub _address: u8,
}
pub type std___unconstref_type = std_remove_const;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_same_uncvref {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___any {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___any() {
    assert_eq!(
        ::std::mem::size_of::<std___any>(),
        1usize,
        concat!("Size of: ", stringify!(std___any))
    );
    assert_eq!(
        ::std::mem::align_of::<std___any>(),
        1usize,
        concat!("Alignment of ", stringify!(std___any))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__15__anyC1Ez"]
    pub fn std___any___any(this: *mut std___any, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_pointer {
    pub _address: u8,
}
pub type std_remove_pointer_type<_Tp> = _Tp;
pub type std___add_pointer_impl_type = *mut std_remove_reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_pointer {
    pub _address: u8,
}
pub type std_add_pointer_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_signed {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_unsigned {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_rank {
    pub _base: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_extent {
    pub _address: u8,
}
pub type std_remove_extent_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_all_extents {
    pub _address: u8,
}
pub type std_remove_all_extents_type<_Tp> = _Tp;
pub type std___decay_type = std_remove_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_decay {
    pub _address: u8,
}
pub type std_decay__Up = std_remove_reference;
pub type std_decay_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_abstract {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_is_final {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_base_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_core_convertible {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_convertible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_polymorphic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_has_virtual_destructor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_alignment_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_list {
    pub _address: u8,
}
pub type std___type_list__Head<_Hp> = _Hp;
pub type std___type_list__Tail<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___nat {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___nat() {
    assert_eq!(
        ::std::mem::size_of::<std___nat>(),
        1usize,
        concat!("Size of: ", stringify!(std___nat))
    );
    assert_eq!(
        ::std::mem::align_of::<std___nat>(),
        1usize,
        concat!("Alignment of ", stringify!(std___nat))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___align_type {
    pub _address: u8,
}
pub type std___align_type_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___struct_double {
    pub __lx: f64,
}
#[test]
fn bindgen_test_layout_std___struct_double() {
    assert_eq!(
        ::std::mem::size_of::<std___struct_double>(),
        8usize,
        concat!("Size of: ", stringify!(std___struct_double))
    );
    assert_eq!(
        ::std::mem::align_of::<std___struct_double>(),
        8usize,
        concat!("Alignment of ", stringify!(std___struct_double))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std___struct_double>())).__lx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___struct_double),
            "::",
            stringify!(__lx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___struct_double4 {
    pub __lx: [f64; 4usize],
}
#[test]
fn bindgen_test_layout_std___struct_double4() {
    assert_eq!(
        ::std::mem::size_of::<std___struct_double4>(),
        32usize,
        concat!("Size of: ", stringify!(std___struct_double4))
    );
    assert_eq!(
        ::std::mem::align_of::<std___struct_double4>(),
        8usize,
        concat!("Alignment of ", stringify!(std___struct_double4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std___struct_double4>())).__lx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___struct_double4),
            "::",
            stringify!(__lx)
        )
    );
}
pub type std___all_types = std___type_list;
extern "C" {
    #[link_name = "\u{1}__min"]
    pub static std___select_align___min: size_t;
}
extern "C" {
    #[link_name = "\u{1}__max"]
    pub static std___select_align___max: size_t;
}
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___select_align_value: size_t;
}
pub type std_aligned_storage__Aligner = u8;
#[repr(C)]
#[derive(Copy, Clone)]
pub union std_aligned_storage_type {
    pub __align: std_aligned_storage__Aligner,
    pub __data: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_std_aligned_storage_type() {
    assert_eq!(
        ::std::mem::size_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Size of: ", stringify!(std_aligned_storage_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Alignment of ", stringify!(std_aligned_storage_type))
    );
}
pub type std_aligned_union_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___numeric_type {
    pub _address: u8,
}
pub type std___numeric_type_type<_Tp> = _Tp;
#[test]
fn __bindgen_test_layout_std___numeric_type_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___numeric_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___numeric_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___numeric_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___numeric_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___promote {
    pub _address: u8,
}
pub type std___signed_types = std___type_list;
pub type std___unsigned_types = std___type_list;
pub type std___apply_cv_type<_Up> = _Up;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_signed {
    pub _address: u8,
}
pub type std_make_signed_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type2_imp {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_types {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_common_type {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_common_type_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_common_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_common_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_common_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_common_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___select_2nd {
    pub _address: u8,
}
pub type std___select_2nd_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_destructible_apply {
    pub _address: u8,
}
pub type std___is_destructible_apply_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_destructor_wellformed {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_destructible {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_is_destructible_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_destructible>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_is_destructible)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_destructible>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_destructible)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___member_pointer_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___member_pointer_class_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_nothrow_destructor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_literal_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_standard_layout {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copyable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivial {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_reference_wrapper_impl {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_reference_wrapper {
    pub _base: std___is_reference_wrapper_impl,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_result_of {
    pub _address: u8,
}
pub type std___swap_result_t = ::std::os::raw::c_void;
pub type std___detail___swappable_with___swap1<_Tp> = _Tp;
pub type std___detail___swappable_with___swap2<_Up> = _Up;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_underlying_type {
    pub _address: u8,
}
pub type std___sfinae_underlying_type_type = std_underlying_type;
pub type std___sfinae_underlying_type___promoted_type = std___sfinae_underlying_type_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___extract_key_fail_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___extract_key_fail_tag() {
    assert_eq!(
        ::std::mem::size_of::<std___extract_key_fail_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std___extract_key_fail_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std___extract_key_fail_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std___extract_key_fail_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___extract_key_self_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___extract_key_self_tag() {
    assert_eq!(
        ::std::mem::size_of::<std___extract_key_self_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std___extract_key_self_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std___extract_key_self_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std___extract_key_self_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___extract_key_first_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___extract_key_first_tag() {
    assert_eq!(
        ::std::mem::size_of::<std___extract_key_first_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std___extract_key_first_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std___extract_key_first_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std___extract_key_first_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___can_extract_key {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___can_extract_map_key {
    pub _address: u8,
}
pub type std___make_const_lvalue_ref = *mut std_remove_reference;
pub type std___move_if_noexcept_result_t<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___equal_to {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binary_function {
    pub _address: u8,
}
pub type std_binary_function_first_argument_type<_Arg1> = _Arg1;
pub type std_binary_function_second_argument_type<_Arg2> = _Arg2;
pub type std_binary_function_result_type<_Result> = _Result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unary_function {
    pub _address: u8,
}
pub type std_unary_function_argument_type<_Arg> = _Arg;
pub type std_unary_function_result_type<_Result> = _Result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_result_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_result_type___two {
    pub __lx: ::std::os::raw::c_char,
    pub __lxx: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___derives_from_unary_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___derives_from_unary_function___two {
    pub __lx: ::std::os::raw::c_char,
    pub __lxx: ::std::os::raw::c_char,
}
pub type std___derives_from_unary_function_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___derives_from_binary_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___derives_from_binary_function___two {
    pub __lx: ::std::os::raw::c_char,
    pub __lxx: ::std::os::raw::c_char,
}
pub type std___derives_from_binary_function_type<_Tp> = _Tp;
pub type std___weak_result_type_imp_result_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___weak_result_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___enable_invoke {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18__invokeENS_5__anyEz"]
    pub fn std___invoke(arg1: std___any, ...) -> std___nat;
}
pub type std___invoke_return_type = std___weak_result_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_return0 {
    pub _address: u8,
}
pub type std___invoke_return0_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_return1 {
    pub _address: u8,
}
pub type std___invoke_return1_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_return2 {
    pub _address: u8,
}
pub type std___invoke_return2_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_plus {
    pub _address: u8,
}
pub type std_plus___result_type<_Tp> = _Tp;
pub type std_plus_result_type<_Tp> = _Tp;
pub type std_plus_first_argument_type<_Tp> = _Tp;
pub type std_plus_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_minus {
    pub _address: u8,
}
pub type std_minus___result_type<_Tp> = _Tp;
pub type std_minus_result_type<_Tp> = _Tp;
pub type std_minus_first_argument_type<_Tp> = _Tp;
pub type std_minus_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_multiplies {
    pub _address: u8,
}
pub type std_multiplies___result_type<_Tp> = _Tp;
pub type std_multiplies_result_type<_Tp> = _Tp;
pub type std_multiplies_first_argument_type<_Tp> = _Tp;
pub type std_multiplies_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_divides {
    pub _address: u8,
}
pub type std_divides___result_type<_Tp> = _Tp;
pub type std_divides_result_type<_Tp> = _Tp;
pub type std_divides_first_argument_type<_Tp> = _Tp;
pub type std_divides_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_modulus {
    pub _address: u8,
}
pub type std_modulus___result_type<_Tp> = _Tp;
pub type std_modulus_result_type<_Tp> = _Tp;
pub type std_modulus_first_argument_type<_Tp> = _Tp;
pub type std_modulus_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_negate {
    pub _address: u8,
}
pub type std_negate___result_type<_Tp> = _Tp;
pub type std_negate_result_type<_Tp> = _Tp;
pub type std_negate_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_and {
    pub _address: u8,
}
pub type std_bit_and___result_type<_Tp> = _Tp;
pub type std_bit_and_result_type<_Tp> = _Tp;
pub type std_bit_and_first_argument_type<_Tp> = _Tp;
pub type std_bit_and_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_or {
    pub _address: u8,
}
pub type std_bit_or___result_type<_Tp> = _Tp;
pub type std_bit_or_result_type<_Tp> = _Tp;
pub type std_bit_or_first_argument_type<_Tp> = _Tp;
pub type std_bit_or_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_xor {
    pub _address: u8,
}
pub type std_bit_xor___result_type<_Tp> = _Tp;
pub type std_bit_xor_result_type<_Tp> = _Tp;
pub type std_bit_xor_first_argument_type<_Tp> = _Tp;
pub type std_bit_xor_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_equal_to {
    pub _address: u8,
}
pub type std_equal_to___result_type = bool;
pub type std_equal_to_result_type = bool;
pub type std_equal_to_first_argument_type<_Tp> = _Tp;
pub type std_equal_to_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_not_equal_to {
    pub _address: u8,
}
pub type std_not_equal_to___result_type = bool;
pub type std_not_equal_to_result_type = bool;
pub type std_not_equal_to_first_argument_type<_Tp> = _Tp;
pub type std_not_equal_to_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less {
    pub _address: u8,
}
pub type std_less___result_type = bool;
pub type std_less_result_type = bool;
pub type std_less_first_argument_type<_Tp> = _Tp;
pub type std_less_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less_equal {
    pub _address: u8,
}
pub type std_less_equal___result_type = bool;
pub type std_less_equal_result_type = bool;
pub type std_less_equal_first_argument_type<_Tp> = _Tp;
pub type std_less_equal_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_greater_equal {
    pub _address: u8,
}
pub type std_greater_equal___result_type = bool;
pub type std_greater_equal_result_type = bool;
pub type std_greater_equal_first_argument_type<_Tp> = _Tp;
pub type std_greater_equal_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_greater {
    pub _address: u8,
}
pub type std_greater___result_type = bool;
pub type std_greater_result_type = bool;
pub type std_greater_first_argument_type<_Tp> = _Tp;
pub type std_greater_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_and {
    pub _address: u8,
}
pub type std_logical_and___result_type = bool;
pub type std_logical_and_result_type = bool;
pub type std_logical_and_first_argument_type<_Tp> = _Tp;
pub type std_logical_and_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_not {
    pub _address: u8,
}
pub type std_logical_not___result_type = bool;
pub type std_logical_not_result_type = bool;
pub type std_logical_not_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_or {
    pub _address: u8,
}
pub type std_logical_or___result_type = bool;
pub type std_logical_or_result_type = bool;
pub type std_logical_or_first_argument_type<_Tp> = _Tp;
pub type std_logical_or_second_argument_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reference_wrapper<_Tp> {
    pub __f_: *mut std_reference_wrapper_type<_Tp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std_reference_wrapper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_allocator_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_allocator_type___two {
    pub __lx: ::std::os::raw::c_char,
    pub __lxx: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uses_allocator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_arg_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_allocator_arg_t() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator_arg_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_allocator_arg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator_arg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_allocator_arg_t))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__113allocator_argE"]
    pub static std_allocator_arg: std_allocator_arg_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple_size {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tuple_like {
    pub _base: std_false_type,
}
pub const std_float_round_style_round_indeterminate: std_float_round_style = -1;
pub const std_float_round_style_round_toward_zero: std_float_round_style = 0;
pub const std_float_round_style_round_to_nearest: std_float_round_style = 1;
pub const std_float_round_style_round_toward_infinity: std_float_round_style = 2;
pub const std_float_round_style_round_toward_neg_infinity: std_float_round_style = 3;
pub type std_float_round_style = ::std::os::raw::c_int;
pub const std_float_denorm_style_denorm_indeterminate: std_float_denorm_style = -1;
pub const std_float_denorm_style_denorm_absent: std_float_denorm_style = 0;
pub const std_float_denorm_style_denorm_present: std_float_denorm_style = 1;
pub type std_float_denorm_style = ::std::os::raw::c_int;
pub type std___libcpp_numeric_limits_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_numeric_limits {
    pub _address: u8,
}
pub type std_numeric_limits___base = u8;
pub type std_numeric_limits_type = std_numeric_limits___base;
extern "C" {
    #[link_name = "\u{1}is_specialized"]
    pub static std_is_specialized: bool;
}
extern "C" {
    #[link_name = "\u{1}digits"]
    pub static std_digits: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}digits10"]
    pub static std_digits10: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}max_digits10"]
    pub static std_max_digits10: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}is_signed"]
    pub static std_is_signed: bool;
}
extern "C" {
    #[link_name = "\u{1}is_integer"]
    pub static std_is_integer: bool;
}
extern "C" {
    #[link_name = "\u{1}is_exact"]
    pub static std_is_exact: bool;
}
extern "C" {
    #[link_name = "\u{1}radix"]
    pub static std_radix: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}min_exponent"]
    pub static std_min_exponent: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}min_exponent10"]
    pub static std_min_exponent10: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}max_exponent"]
    pub static std_max_exponent: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}max_exponent10"]
    pub static std_max_exponent10: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}has_infinity"]
    pub static std_has_infinity: bool;
}
extern "C" {
    #[link_name = "\u{1}has_quiet_NaN"]
    pub static std_has_quiet_NaN: bool;
}
extern "C" {
    #[link_name = "\u{1}has_signaling_NaN"]
    pub static std_has_signaling_NaN: bool;
}
extern "C" {
    #[link_name = "\u{1}has_denorm"]
    pub static std_has_denorm: std_float_denorm_style;
}
extern "C" {
    #[link_name = "\u{1}has_denorm_loss"]
    pub static std_has_denorm_loss: bool;
}
extern "C" {
    #[link_name = "\u{1}is_iec559"]
    pub static std_is_iec559: bool;
}
extern "C" {
    #[link_name = "\u{1}is_bounded"]
    pub static std_is_bounded: bool;
}
extern "C" {
    #[link_name = "\u{1}is_modulo"]
    pub static std_is_modulo: bool;
}
extern "C" {
    #[link_name = "\u{1}traps"]
    pub static std_traps: bool;
}
extern "C" {
    #[link_name = "\u{1}tinyness_before"]
    pub static std_tinyness_before: bool;
}
extern "C" {
    #[link_name = "\u{1}round_style"]
    pub static std_round_style: std_float_round_style;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___unwrap_reference {
    pub _address: u8,
}
pub type std___unwrap_reference_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___unwrap_ref_decay {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_piecewise_construct_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_piecewise_construct_t() {
    assert_eq!(
        ::std::mem::size_of::<std_piecewise_construct_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_piecewise_construct_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_piecewise_construct_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_piecewise_construct_t))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__119piecewise_constructE"]
    pub static std_piecewise_construct: std_piecewise_construct_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair<_T1, _T2> {
    pub first: _T1,
    pub second: _T2,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T1>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T2>>,
}
pub type std_pair_first_type<_T1> = _T1;
pub type std_pair_second_type<_T2> = _T2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_input_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_input_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_input_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_input_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_input_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_input_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_output_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_output_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_output_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_output_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_output_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_output_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_forward_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_forward_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_forward_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bidirectional_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_bidirectional_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_bidirectional_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_bidirectional_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_random_access_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_random_access_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_random_access_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_random_access_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_random_access_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_random_access_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iter_traits_cache {
    pub _address: u8,
}
pub type std___iter_traits_cache_type = std__If;
pub type std__ITER_TRAITS = std___iter_traits_cache;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iter_concept_concept_test {
    pub _address: u8,
}
pub type std___iter_concept_concept_test__Apply = std__ITER_TRAITS;
#[test]
fn bindgen_test_layout_std___iter_concept_concept_test() {
    assert_eq!(
        ::std::mem::size_of::<std___iter_concept_concept_test>(),
        1usize,
        concat!("Size of: ", stringify!(std___iter_concept_concept_test))
    );
    assert_eq!(
        ::std::mem::align_of::<std___iter_concept_concept_test>(),
        1usize,
        concat!("Alignment of ", stringify!(std___iter_concept_concept_test))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iter_concept_category_test {
    pub _address: u8,
}
pub type std___iter_concept_category_test__Apply = std__ITER_TRAITS;
#[test]
fn bindgen_test_layout_std___iter_concept_category_test() {
    assert_eq!(
        ::std::mem::size_of::<std___iter_concept_category_test>(),
        1usize,
        concat!("Size of: ", stringify!(std___iter_concept_category_test))
    );
    assert_eq!(
        ::std::mem::align_of::<std___iter_concept_category_test>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___iter_concept_category_test)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iter_concept_random_fallback {
    pub _address: u8,
}
pub type std___iter_concept_random_fallback__Apply = std__EnableIf;
#[test]
fn bindgen_test_layout_std___iter_concept_random_fallback() {
    assert_eq!(
        ::std::mem::size_of::<std___iter_concept_random_fallback>(),
        1usize,
        concat!("Size of: ", stringify!(std___iter_concept_random_fallback))
    );
    assert_eq!(
        ::std::mem::align_of::<std___iter_concept_random_fallback>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___iter_concept_random_fallback)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___test_iter_concept<_Tester> {
    pub _base_1: _Tester,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tester>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iter_concept_cache {
    pub _address: u8,
}
pub type std___iter_concept_cache_type = std__Or;
pub type std__ITER_CONCEPT = std___iter_concept_cache;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_iterator_typedefs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_iterator_typedefs___two {
    pub __lx: ::std::os::raw::c_char,
    pub __lxx: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_iterator_category {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_iterator_category___two {
    pub __lx: ::std::os::raw::c_char,
    pub __lxx: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_iterator_concept {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_iterator_concept___two {
    pub __lx: ::std::os::raw::c_char,
    pub __lxx: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
pub type std_iterator_traits___primary_template = std_iterator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_cpp17_input_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_cpp17_forward_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_cpp17_bidirectional_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_cpp17_random_access_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_cpp17_contiguous_iterator {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_exactly_cpp17_input_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binary_negate<_Predicate> {
    pub __pred_: _Predicate,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_bind_expression {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_bind_expression {
    pub _base: std___is_bind_expression,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_placeholder {
    pub _base: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_placeholder {
    pub _base: std___is_placeholder,
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112placeholders2_1E"]
    pub static std_placeholders__1: u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112placeholders2_2E"]
    pub static std_placeholders__2: u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112placeholders2_3E"]
    pub static std_placeholders__3: u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112placeholders2_4E"]
    pub static std_placeholders__4: u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112placeholders2_5E"]
    pub static std_placeholders__5: u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112placeholders2_6E"]
    pub static std_placeholders__6: u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112placeholders2_7E"]
    pub static std_placeholders__7: u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112placeholders2_8E"]
    pub static std_placeholders__8: u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112placeholders2_9E"]
    pub static std_placeholders__9: u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112placeholders3_10E"]
    pub static std_placeholders__10: u8;
}
#[repr(C)]
pub struct std_binder1st<__Operation> {
    pub op: __Operation,
    pub value: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<__Operation>>,
}
#[repr(C)]
pub struct std_binder2nd<__Operation> {
    pub op: __Operation,
    pub value: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<__Operation>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_element_type {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_difference_type {
    pub _base: std_false_type,
}
pub type std___pointer_traits_difference_type_type = isize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_rebind {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_rebind___two {
    pub __lx: ::std::os::raw::c_char,
    pub __lxx: ::std::os::raw::c_char,
}
pub type std___pointer_traits_rebind_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
pub type std_pointer_traits_pointer<_Ptr> = _Ptr;
pub type std_pointer_traits_element_type = u8;
pub type std_pointer_traits_difference_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits_rebind {
    pub _address: u8,
}
pub type std_pointer_traits_rebind_other = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits___nat {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___rebind_pointer {
    pub _address: u8,
}
pub type std___rebind_pointer_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___to_address_helper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_pointer {
    pub _base: std_false_type,
}
pub type std___pointer_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_const_pointer {
    pub _base: std_false_type,
}
pub type std___const_pointer_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_void_pointer {
    pub _base: std_false_type,
}
pub type std___void_pointer_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_const_void_pointer {
    pub _base: std_false_type,
}
pub type std___const_void_pointer_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_size_type {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_alloc_traits_difference_type {
    pub _base: std_false_type,
}
pub type std___alloc_traits_difference_type_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_propagate_on_container_copy_assignment {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_propagate_on_container_move_assignment {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_propagate_on_container_swap {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_is_always_equal {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_rebind_other {
    pub _base: std_false_type,
}
pub type std___allocator_traits_rebind_type<_Tp> = _Tp;
pub type std___allocator_traits_rebind_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_allocate_hint {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_construct_impl {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_construct {
    pub _base: std___has_construct_impl,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_destroy {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_max_size {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_select_on_container_copy_construction {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = [u8; 0usize];
pub type std_allocator_traits_pointer = [u8; 0usize];
pub type std_allocator_traits_const_pointer = [u8; 0usize];
pub type std_allocator_traits_void_pointer = [u8; 0usize];
pub type std_allocator_traits_const_void_pointer = [u8; 0usize];
pub type std_allocator_traits_difference_type = [u8; 0usize];
pub type std_allocator_traits_size_type = [u8; 0usize];
pub type std_allocator_traits_propagate_on_container_copy_assignment = u8;
pub type std_allocator_traits_propagate_on_container_move_assignment = u8;
pub type std_allocator_traits_propagate_on_container_swap = u8;
pub type std_allocator_traits_is_always_equal = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits_rebind_alloc {
    pub _address: u8,
}
pub type std_allocator_traits_rebind_alloc_other = std___allocator_traits_rebind_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits_rebind_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___rebind_alloc_helper {
    pub _address: u8,
}
pub type std___rebind_alloc_helper_type<_Traits> = _Traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_default_allocator {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_cpp17_move_insertable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_cpp17_copy_insertable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___default_init_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___default_init_tag() {
    assert_eq!(
        ::std::mem::size_of::<std___default_init_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std___default_init_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std___default_init_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std___default_init_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___value_init_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___value_init_tag() {
    assert_eq!(
        ::std::mem::size_of::<std___value_init_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std___value_init_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std___value_init_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std___value_init_tag))
    );
}
pub type std___compressed_pair_elem__ParamT<_Tp> = _Tp;
pub type std___compressed_pair_elem_reference<_Tp> = *mut _Tp;
pub type std___compressed_pair_elem_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___compressed_pair {
    pub _address: u8,
}
pub type std___compressed_pair__Base1 = u8;
pub type std___compressed_pair__Base2 = u8;
#[repr(C)]
#[derive(Debug)]
pub struct std___allocation_guard<_Alloc> {
    pub __alloc_: _Alloc,
    pub __n_: std___allocation_guard__Size,
    pub __ptr_: std___allocation_guard__Pointer,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
}
pub type std___allocation_guard__Pointer = std_allocator_traits;
pub type std___allocation_guard__Size = std_allocator_traits;
#[repr(C)]
#[derive(Debug)]
pub struct std___libcpp_refstring {
    pub __imp_: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_std___libcpp_refstring() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_refstring>(),
        8usize,
        concat!("Size of: ", stringify!(std___libcpp_refstring))
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_refstring>(),
        8usize,
        concat!("Alignment of ", stringify!(std___libcpp_refstring))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std___libcpp_refstring>())).__imp_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___libcpp_refstring),
            "::",
            stringify!(__imp_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__121__throw_runtime_errorEPKc"]
    pub fn std___throw_runtime_error(arg1: *const ::std::os::raw::c_char);
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_const_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = size_t;
pub type std_allocator_difference_type = isize;
pub type std_allocator_value_type<_Tp> = _Tp;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__PairT {
    pub first: size_t,
    pub second: size_t,
}
#[test]
fn bindgen_test_layout_std__PairT() {
    assert_eq!(
        ::std::mem::size_of::<std__PairT>(),
        16usize,
        concat!("Size of: ", stringify!(std__PairT))
    );
    assert_eq!(
        ::std::mem::align_of::<std__PairT>(),
        8usize,
        concat!("Alignment of ", stringify!(std__PairT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std__PairT>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__PairT),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std__PairT>())).second as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std__PairT),
            "::",
            stringify!(second)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_long_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_auto_ptr_ref<_Tp> {
    pub __ptr_: *mut _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_auto_ptr<_Tp> {
    pub __ptr_: *mut _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std_auto_ptr_element_type<_Tp> = _Tp;
#[test]
fn __bindgen_test_layout_std_auto_ptr_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_auto_ptr<::std::os::raw::c_void>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_auto_ptr<::std::os::raw::c_void>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_auto_ptr<::std::os::raw::c_void>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_auto_ptr<::std::os::raw::c_void>)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___unique_ptr_deleter_sfinae {
    pub _address: u8,
}
pub type std___unique_ptr_deleter_sfinae___lval_ref_type<_Deleter> = *const _Deleter;
pub type std___unique_ptr_deleter_sfinae___good_rval_ref_type<_Deleter> = *mut _Deleter;
pub type std___unique_ptr_deleter_sfinae___enable_rval_overload = std_true_type;
#[repr(C)]
#[derive(Debug)]
pub struct std_unique_ptr {
    pub __ptr_: std___compressed_pair,
}
pub type std_unique_ptr_element_type<_Tp> = _Tp;
pub type std_unique_ptr_deleter_type<_Dp> = _Dp;
pub type std_unique_ptr_pointer = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unique_ptr___nat {
    pub __for_bool_: ::std::os::raw::c_int,
}
pub type std_unique_ptr__DeleterSFINAE = std___unique_ptr_deleter_sfinae;
pub type std_unique_ptr__LValRefType = u8;
pub type std_unique_ptr__GoodRValRefType = u8;
pub type std_unique_ptr__BadRValRefType = u8;
pub type std_unique_ptr__EnableIfDeleterDefaultConstructible = u8;
pub type std_unique_ptr__EnableIfDeleterConstructible = u8;
pub type std_unique_ptr__EnableIfMoveConvertible = u8;
pub type std_unique_ptr__EnableIfDeleterConvertible = u8;
pub type std_unique_ptr__EnableIfDeleterAssignable = u8;
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___static_gcd_value: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___static_lcm_value: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___static_abs_value: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___static_sign_value: intmax_t;
}
pub const std___ll_mul_nan: intmax_t = -9223372036854775808;
extern "C" {
    #[link_name = "\u{1}min"]
    pub static std___ll_mul_min: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}max"]
    pub static std___ll_mul_max: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}__a_x"]
    pub static std___ll_mul___a_x: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}__a_y"]
    pub static std___ll_mul___a_y: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___ll_mul_value: intmax_t;
}
pub const std___ll_div_nan: intmax_t = -9223372036854775808;
extern "C" {
    #[link_name = "\u{1}min"]
    pub static std___ll_div_min: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}max"]
    pub static std___ll_div_max: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___ll_div_value: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}__na"]
    pub static std_ratio___na: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}__da"]
    pub static std_ratio___da: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}__s"]
    pub static std_ratio___s: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}__gcd"]
    pub static std_ratio___gcd: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}num"]
    pub static std_ratio_num: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}den"]
    pub static std_ratio_den: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}num"]
    pub static std_num: intmax_t;
}
extern "C" {
    #[link_name = "\u{1}den"]
    pub static std_den: intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_ratio {
    pub _base: std_false_type,
}
pub type std_atto = u8;
pub type std_femto = u8;
pub type std_pico = u8;
pub type std_nano = u8;
pub type std_micro = u8;
pub type std_milli = u8;
pub type std_centi = u8;
pub type std_deci = u8;
pub type std_deca = u8;
pub type std_hecto = u8;
pub type std_kilo = u8;
pub type std_mega = u8;
pub type std_giga = u8;
pub type std_tera = u8;
pub type std_peta = u8;
pub type std_exa = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_multiply {
    pub _address: u8,
}
pub type std___ratio_multiply_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_multiply {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_divide {
    pub _address: u8,
}
pub type std___ratio_divide_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_divide {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_add {
    pub _address: u8,
}
pub type std___ratio_add_type = std_ratio_multiply;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_add {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_subtract {
    pub _address: u8,
}
pub type std___ratio_subtract_type = std_ratio_multiply;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_subtract {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_not_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_less_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_greater {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_greater_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_gcd {
    pub _address: u8,
}
pub type std___ratio_gcd_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono___is_duration {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_treat_as_floating_point {
    pub _base: std_is_floating_point,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_duration_values {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_duration<_Rep> {
    pub __rep_: std_chrono_duration_rep<_Rep>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Rep>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_duration___no_overflow {
    pub _address: u8,
}
pub type std_chrono_duration___no_overflow_type = u8;
pub type std_chrono_duration_rep<_Rep> = _Rep;
pub type std_chrono_duration_period = [u8; 0usize];
pub type std_chrono_nanoseconds = std_chrono_duration<::std::os::raw::c_longlong>;
pub type std_chrono_microseconds = std_chrono_duration<::std::os::raw::c_longlong>;
pub type std_chrono_milliseconds = std_chrono_duration<::std::os::raw::c_longlong>;
pub type std_chrono_seconds = std_chrono_duration<::std::os::raw::c_longlong>;
pub type std_chrono_minutes = std_chrono_duration<::std::os::raw::c_long>;
pub type std_chrono_hours = std_chrono_duration<::std::os::raw::c_long>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono___duration_eq {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono___duration_lt {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_time_point<_Duration> {
    pub __d_: std_chrono_time_point_duration<_Duration>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Duration>>,
}
pub type std_chrono_time_point_clock<_Clock> = _Clock;
pub type std_chrono_time_point_duration<_Duration> = _Duration;
pub type std_chrono_time_point_rep = [u8; 0usize];
pub type std_chrono_time_point_period = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_system_clock {
    pub _address: u8,
}
pub type std_chrono_system_clock_duration = std_chrono_microseconds;
pub type std_chrono_system_clock_rep = rep;
pub type std_chrono_system_clock_period = u8;
pub type std_chrono_system_clock_time_point =
    std_chrono_time_point<std_chrono_duration<::std::os::raw::c_longlong>>;
pub const std_chrono_system_clock_is_steady: bool = false;
#[test]
fn bindgen_test_layout_std_chrono_system_clock() {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_system_clock>(),
        1usize,
        concat!("Size of: ", stringify!(std_chrono_system_clock))
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_system_clock>(),
        1usize,
        concat!("Alignment of ", stringify!(std_chrono_system_clock))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16chrono12system_clock3nowEv"]
    pub fn std_chrono_system_clock_now() -> std_chrono_system_clock_time_point;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16chrono12system_clock9to_time_tERKNS0_10time_pointIS1_NS0_8durationIxNS_5ratioILl1ELl1000000EEEEEEE"]
    pub fn std_chrono_system_clock_to_time_t(
        __t: *const std_chrono_system_clock_time_point,
    ) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16chrono12system_clock11from_time_tEl"]
    pub fn std_chrono_system_clock_from_time_t(__t: time_t) -> std_chrono_system_clock_time_point;
}
impl std_chrono_system_clock {
    #[inline]
    pub unsafe fn now() -> std_chrono_system_clock_time_point {
        std_chrono_system_clock_now()
    }
    #[inline]
    pub unsafe fn to_time_t(__t: *const std_chrono_system_clock_time_point) -> time_t {
        std_chrono_system_clock_to_time_t(__t)
    }
    #[inline]
    pub unsafe fn from_time_t(__t: time_t) -> std_chrono_system_clock_time_point {
        std_chrono_system_clock_from_time_t(__t)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_steady_clock {
    pub _address: u8,
}
pub type std_chrono_steady_clock_duration = std_chrono_nanoseconds;
pub type std_chrono_steady_clock_rep = rep;
pub type std_chrono_steady_clock_period = u8;
pub type std_chrono_steady_clock_time_point =
    std_chrono_time_point<std_chrono_steady_clock_duration>;
pub const std_chrono_steady_clock_is_steady: bool = true;
#[test]
fn bindgen_test_layout_std_chrono_steady_clock() {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_steady_clock>(),
        1usize,
        concat!("Size of: ", stringify!(std_chrono_steady_clock))
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_steady_clock>(),
        1usize,
        concat!("Alignment of ", stringify!(std_chrono_steady_clock))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__16chrono12steady_clock3nowEv"]
    pub fn std_chrono_steady_clock_now() -> std_chrono_steady_clock_time_point;
}
impl std_chrono_steady_clock {
    #[inline]
    pub unsafe fn now() -> std_chrono_steady_clock_time_point {
        std_chrono_steady_clock_now()
    }
}
pub type std_chrono_high_resolution_clock = std_chrono_steady_clock;
pub const std___libcpp_polling_count: ::std::os::raw::c_int = 64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___spinning_backoff_policy {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___spinning_backoff_policy() {
    assert_eq!(
        ::std::mem::size_of::<std___spinning_backoff_policy>(),
        1usize,
        concat!("Size of: ", stringify!(std___spinning_backoff_policy))
    );
    assert_eq!(
        ::std::mem::align_of::<std___spinning_backoff_policy>(),
        1usize,
        concat!("Alignment of ", stringify!(std___spinning_backoff_policy))
    );
}
pub type std___libcpp_mutex_t = pthread_mutex_t;
pub type std___libcpp_recursive_mutex_t = pthread_mutex_t;
pub type std___libcpp_condvar_t = pthread_cond_t;
pub type std___libcpp_exec_once_flag = pthread_once_t;
pub type std___libcpp_thread_id = pthread_t;
pub type std___libcpp_thread_t = pthread_t;
pub type std___libcpp_tls_key = pthread_key_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_timed_backoff_policy {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___libcpp_timed_backoff_policy() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_timed_backoff_policy>(),
        1usize,
        concat!("Size of: ", stringify!(std___libcpp_timed_backoff_policy))
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_timed_backoff_policy>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___libcpp_timed_backoff_policy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_thread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___thread_id {
    pub __id_: std___libcpp_thread_id,
}
#[test]
fn bindgen_test_layout_std___thread_id() {
    assert_eq!(
        ::std::mem::size_of::<std___thread_id>(),
        8usize,
        concat!("Size of: ", stringify!(std___thread_id))
    );
    assert_eq!(
        ::std::mem::align_of::<std___thread_id>(),
        8usize,
        concat!("Alignment of ", stringify!(std___thread_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std___thread_id>())).__id_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___thread_id),
            "::",
            stringify!(__id_)
        )
    );
}
pub const std___legacy_memory_order___mo_relaxed: std___legacy_memory_order = 0;
pub const std___legacy_memory_order___mo_consume: std___legacy_memory_order = 1;
pub const std___legacy_memory_order___mo_acquire: std___legacy_memory_order = 2;
pub const std___legacy_memory_order___mo_release: std___legacy_memory_order = 3;
pub const std___legacy_memory_order___mo_acq_rel: std___legacy_memory_order = 4;
pub const std___legacy_memory_order___mo_seq_cst: std___legacy_memory_order = 5;
pub type std___legacy_memory_order = ::std::os::raw::c_uint;
pub type std___memory_order_underlying_t = type_;
pub const std_memory_order_memory_order_relaxed: std_memory_order = 0;
pub const std_memory_order_memory_order_consume: std_memory_order = 1;
pub const std_memory_order_memory_order_acquire: std_memory_order = 2;
pub const std_memory_order_memory_order_release: std_memory_order = 3;
pub const std_memory_order_memory_order_acq_rel: std_memory_order = 4;
pub const std_memory_order_memory_order_seq_cst: std_memory_order = 5;
pub type std_memory_order = ::std::os::raw::c_uint;
#[repr(C)]
pub struct std___cxx_atomic_base_impl {
    pub __a_value: [u8; 0usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___cxx_atomic_impl<_Base> {
    pub _base: _Base,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Base>>,
}
pub type std___cxx_contention_t = i64;
pub type std___cxx_atomic_contention_t = std___cxx_atomic_impl<std___cxx_atomic_base_impl>;
extern "C" {
    #[link_name = "\u{1}__ZNSt3__123__cxx_atomic_notify_oneEPVKv"]
    pub fn std___cxx_atomic_notify_one(arg1: *const ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__123__cxx_atomic_notify_allEPVKv"]
    pub fn std___cxx_atomic_notify_all(arg1: *const ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__123__libcpp_atomic_monitorEPVKv"]
    pub fn std___libcpp_atomic_monitor(
        arg1: *const ::std::os::raw::c_void,
    ) -> std___cxx_contention_t;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__120__libcpp_atomic_waitEPVKvx"]
    pub fn std___libcpp_atomic_wait(
        arg1: *const ::std::os::raw::c_void,
        arg2: std___cxx_contention_t,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__123__cxx_atomic_notify_oneEPVKNS_17__cxx_atomic_implIxNS_22__cxx_atomic_base_implIxEEEE"]
    pub fn std___cxx_atomic_notify_one1(arg1: *const std___cxx_atomic_contention_t);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__123__cxx_atomic_notify_allEPVKNS_17__cxx_atomic_implIxNS_22__cxx_atomic_base_implIxEEEE"]
    pub fn std___cxx_atomic_notify_all1(arg1: *const std___cxx_atomic_contention_t);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__123__libcpp_atomic_monitorEPVKNS_17__cxx_atomic_implIxNS_22__cxx_atomic_base_implIxEEEE"]
    pub fn std___libcpp_atomic_monitor1(
        arg1: *const std___cxx_atomic_contention_t,
    ) -> std___cxx_contention_t;
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__120__libcpp_atomic_waitEPVKNS_17__cxx_atomic_implIxNS_22__cxx_atomic_base_implIxEEEEx"]
    pub fn std___libcpp_atomic_wait1(
        arg1: *const std___cxx_atomic_contention_t,
        arg2: std___cxx_contention_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_atomic_wait_backoff_impl<_Atp, _Fn> {
    pub __a: *mut _Atp,
    pub __test_fn: _Fn,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Atp>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Fn>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___cxx_atomic_wait_test_fn_impl<_Atp, _Tp> {
    pub __a: *mut _Atp,
    pub __val: _Tp,
    pub __order: std_memory_order,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Atp>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_atomic {
    pub _address: u8,
}
pub type std_atomic___base = u8;
pub type std_atomic_value_type<_Tp> = _Tp;
pub type std_atomic_difference_type<_Tp> = std_atomic_value_type<_Tp>;
#[repr(C)]
pub struct std_atomic_flag {
    pub __a_: std___cxx_atomic_impl<std___cxx_atomic_base_impl>,
}
#[test]
fn bindgen_test_layout_std_atomic_flag() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic_flag>(),
        1usize,
        concat!("Size of: ", stringify!(std_atomic_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic_flag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_atomic_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_atomic_flag>())).__a_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_atomic_flag),
            "::",
            stringify!(__a_)
        )
    );
}
pub type std_atomic_bool = std_atomic;
pub type std_atomic_char = std_atomic;
pub type std_atomic_schar = std_atomic;
pub type std_atomic_uchar = std_atomic;
pub type std_atomic_short = std_atomic;
pub type std_atomic_ushort = std_atomic;
pub type std_atomic_int = std_atomic;
pub type std_atomic_uint = std_atomic;
pub type std_atomic_long = std_atomic;
pub type std_atomic_ulong = std_atomic;
pub type std_atomic_llong = std_atomic;
pub type std_atomic_ullong = std_atomic;
pub type std_atomic_char16_t = std_atomic;
pub type std_atomic_char32_t = std_atomic;
pub type std_atomic_wchar_t = std_atomic;
pub type std_atomic_int_least8_t = std_atomic;
pub type std_atomic_uint_least8_t = std_atomic;
pub type std_atomic_int_least16_t = std_atomic;
pub type std_atomic_uint_least16_t = std_atomic;
pub type std_atomic_int_least32_t = std_atomic;
pub type std_atomic_uint_least32_t = std_atomic;
pub type std_atomic_int_least64_t = std_atomic;
pub type std_atomic_uint_least64_t = std_atomic;
pub type std_atomic_int_fast8_t = std_atomic;
pub type std_atomic_uint_fast8_t = std_atomic;
pub type std_atomic_int_fast16_t = std_atomic;
pub type std_atomic_uint_fast16_t = std_atomic;
pub type std_atomic_int_fast32_t = std_atomic;
pub type std_atomic_uint_fast32_t = std_atomic;
pub type std_atomic_int_fast64_t = std_atomic;
pub type std_atomic_uint_fast64_t = std_atomic;
pub type std_atomic_int8_t = std_atomic;
pub type std_atomic_uint8_t = std_atomic;
pub type std_atomic_int16_t = std_atomic;
pub type std_atomic_uint16_t = std_atomic;
pub type std_atomic_int32_t = std_atomic;
pub type std_atomic_uint32_t = std_atomic;
pub type std_atomic_int64_t = std_atomic;
pub type std_atomic_uint64_t = std_atomic;
pub type std_atomic_intptr_t = std_atomic;
pub type std_atomic_uintptr_t = std_atomic;
pub type std_atomic_size_t = std_atomic;
pub type std_atomic_ptrdiff_t = std_atomic;
pub type std_atomic_intmax_t = std_atomic;
pub type std_atomic_uintmax_t = std_atomic;
pub type std___libcpp_signed_lock_free = type_;
pub type std___libcpp_unsigned_lock_free = type_;
pub type std_atomic_signed_lock_free = std_atomic;
pub type std_atomic_unsigned_lock_free = std_atomic;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_destructor<_Alloc> {
    pub __alloc_: *mut _Alloc,
    pub __s_: std___allocator_destructor_size_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
}
pub type std___allocator_destructor___alloc_traits = std_allocator_traits;
pub type std___allocator_destructor_pointer = std___allocator_destructor___alloc_traits;
pub type std___allocator_destructor_size_type = std___allocator_destructor___alloc_traits;
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_weak_ptr {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_weak_ptr() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_weak_ptr>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_weak_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_weak_ptr>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_weak_ptr))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112bad_weak_ptrD1Ev"]
    pub fn std_bad_weak_ptr_bad_weak_ptr_destructor(this: *mut std_bad_weak_ptr);
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt3__112bad_weak_ptr4whatEv"]
    pub fn std_bad_weak_ptr_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
pub struct std___shared_count__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std___shared_count {
    pub vtable_: *const std___shared_count__bindgen_vtable,
    pub __shared_owners_: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_std___shared_count() {
    assert_eq!(
        ::std::mem::size_of::<std___shared_count>(),
        16usize,
        concat!("Size of: ", stringify!(std___shared_count))
    );
    assert_eq!(
        ::std::mem::align_of::<std___shared_count>(),
        8usize,
        concat!("Alignment of ", stringify!(std___shared_count))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std___shared_count>())).__shared_owners_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std___shared_count),
            "::",
            stringify!(__shared_owners_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__114__shared_countD1Ev"]
    pub fn std___shared_count___shared_count_destructor(this: *mut std___shared_count);
}
#[repr(C)]
#[derive(Debug)]
pub struct std___shared_weak_count {
    pub _base: std___shared_count,
    pub __shared_weak_owners_: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_std___shared_weak_count() {
    assert_eq!(
        ::std::mem::size_of::<std___shared_weak_count>(),
        24usize,
        concat!("Size of: ", stringify!(std___shared_weak_count))
    );
    assert_eq!(
        ::std::mem::align_of::<std___shared_weak_count>(),
        8usize,
        concat!("Alignment of ", stringify!(std___shared_weak_count))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std___shared_weak_count>())).__shared_weak_owners_ as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std___shared_weak_count),
            "::",
            stringify!(__shared_weak_owners_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__119__shared_weak_count14__release_weakEv"]
    pub fn std___shared_weak_count___release_weak(this: *mut std___shared_weak_count);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__119__shared_weak_count4lockEv"]
    pub fn std___shared_weak_count_lock(
        this: *mut std___shared_weak_count,
    ) -> *mut std___shared_weak_count;
}
impl std___shared_weak_count {
    #[inline]
    pub unsafe fn __release_weak(&mut self) {
        std___shared_weak_count___release_weak(self)
    }
    #[inline]
    pub unsafe fn lock(&mut self) -> *mut std___shared_weak_count {
        std___shared_weak_count_lock(self)
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__119__shared_weak_countD1Ev"]
    pub fn std___shared_weak_count___shared_weak_count_destructor(
        this: *mut std___shared_weak_count,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt3__119__shared_weak_count13__get_deleterERKSt9type_info"]
    pub fn std___shared_weak_count___get_deleter(
        this: *mut ::std::os::raw::c_void,
        arg1: *const std_type_info,
    ) -> *const ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug)]
pub struct std___shared_ptr_pointer {
    pub _base: std___shared_weak_count,
    pub __data_: std___compressed_pair,
}
#[repr(C)]
#[derive(Debug)]
pub struct std___shared_ptr_emplace {
    pub _base: std___shared_weak_count,
    pub __storage_: std___shared_ptr_emplace__Storage,
}
pub type std___shared_ptr_emplace__CompressedPair = std___compressed_pair;
#[repr(C)]
#[derive(Debug)]
pub struct std___shared_ptr_emplace__Storage {
    pub __blob_: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___shared_ptr_dummy_rebind_allocator_type {
    _unused: [u8; 0],
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std___shared_ptr_dummy_rebind_allocator_type_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___compatible_with {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_deletable {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_array_deletable {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___well_formed_deleter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___shared_ptr_deleter_ctor_reqs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_shared_ptr<_Tp> {
    pub __ptr_: *mut std_shared_ptr_element_type<_Tp>,
    pub __cntrl_: *mut std___shared_weak_count,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std_shared_ptr_element_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_shared_ptr___nat {
    pub __for_bool_: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_shared_ptr___shared_ptr_default_delete {
    pub _address: u8,
}
pub type std_shared_ptr___shared_ptr_default_allocator_type = std_allocator;
#[repr(C)]
#[derive(Debug)]
pub struct std_weak_ptr<_Tp> {
    pub __ptr_: *mut std_weak_ptr_element_type<_Tp>,
    pub __cntrl_: *mut std___shared_weak_count,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std_weak_ptr_element_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_owner_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_enable_shared_from_this<_Tp> {
    pub __weak_this_: std_weak_ptr<_Tp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___sp_mut {
    pub __lx: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_std___sp_mut() {
    assert_eq!(
        ::std::mem::size_of::<std___sp_mut>(),
        8usize,
        concat!("Size of: ", stringify!(std___sp_mut))
    );
    assert_eq!(
        ::std::mem::align_of::<std___sp_mut>(),
        8usize,
        concat!("Alignment of ", stringify!(std___sp_mut))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std___sp_mut>())).__lx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___sp_mut),
            "::",
            stringify!(__lx)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18__sp_mut4lockEv"]
    pub fn std___sp_mut_lock(this: *mut std___sp_mut);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18__sp_mut6unlockEv"]
    pub fn std___sp_mut_unlock(this: *mut std___sp_mut);
}
impl std___sp_mut {
    #[inline]
    pub unsafe fn lock(&mut self) {
        std___sp_mut_lock(self)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) {
        std___sp_mut_unlock(self)
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112__get_sp_mutEPKv"]
    pub fn std___get_sp_mut(arg1: *const ::std::os::raw::c_void) -> *mut std___sp_mut;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
pub type std_iterator_iterator_category<_Category> = _Category;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_back_insert_iterator<_Container> {
    pub container: *mut _Container,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
}
pub type std_back_insert_iterator_iterator_category = std_output_iterator_tag;
pub type std_back_insert_iterator_value_type = ::std::os::raw::c_void;
pub type std_back_insert_iterator_difference_type = ::std::os::raw::c_void;
pub type std_back_insert_iterator_pointer = ::std::os::raw::c_void;
pub type std_back_insert_iterator_reference = ::std::os::raw::c_void;
pub type std_back_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_front_insert_iterator<_Container> {
    pub container: *mut _Container,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
}
pub type std_front_insert_iterator_iterator_category = std_output_iterator_tag;
pub type std_front_insert_iterator_value_type = ::std::os::raw::c_void;
pub type std_front_insert_iterator_difference_type = ::std::os::raw::c_void;
pub type std_front_insert_iterator_pointer = ::std::os::raw::c_void;
pub type std_front_insert_iterator_reference = ::std::os::raw::c_void;
pub type std_front_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
pub struct std_insert_iterator<_Container> {
    pub container: *mut _Container,
    pub iter: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
}
pub type std_insert_iterator_iterator_category = std_output_iterator_tag;
pub type std_insert_iterator_value_type = ::std::os::raw::c_void;
pub type std_insert_iterator_difference_type = ::std::os::raw::c_void;
pub type std_insert_iterator_pointer = ::std::os::raw::c_void;
pub type std_insert_iterator_reference = ::std::os::raw::c_void;
pub type std_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_istreambuf_iterator {
    pub __sbuf_: *mut std_istreambuf_iterator_streambuf_type,
}
pub type std_istreambuf_iterator_iterator_category = std_input_iterator_tag;
pub type std_istreambuf_iterator_value_type<_CharT> = _CharT;
pub type std_istreambuf_iterator_difference_type = [u8; 0usize];
pub type std_istreambuf_iterator_pointer<_CharT> = *mut _CharT;
pub type std_istreambuf_iterator_reference<_CharT> = _CharT;
pub type std_istreambuf_iterator_char_type<_CharT> = _CharT;
pub type std_istreambuf_iterator_traits_type<_Traits> = _Traits;
pub type std_istreambuf_iterator_int_type = [u8; 0usize];
pub type std_istreambuf_iterator_streambuf_type = std_basic_streambuf;
pub type std_istreambuf_iterator_istream_type = std_basic_istream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_istreambuf_iterator___proxy<_CharT> {
    pub __keep_: std_istreambuf_iterator_char_type<_CharT>,
    pub __sbuf_: *mut std_istreambuf_iterator_streambuf_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_istream_iterator<_Tp> {
    pub __in_stream_: *mut std_istream_iterator_istream_type,
    pub __value_: _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std_istream_iterator_iterator_category = std_input_iterator_tag;
pub type std_istream_iterator_value_type<_Tp> = _Tp;
pub type std_istream_iterator_difference_type<_Distance> = _Distance;
pub type std_istream_iterator_pointer<_Tp> = *const _Tp;
pub type std_istream_iterator_reference<_Tp> = *const _Tp;
pub type std_istream_iterator_char_type<_CharT> = _CharT;
pub type std_istream_iterator_traits_type<_Traits> = _Traits;
pub type std_istream_iterator_istream_type = std_basic_istream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_move_iterator<_Iter> {
    pub __i: _Iter,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iter>>,
}
pub type std_move_iterator_iterator_type<_Iter> = _Iter;
pub type std_move_iterator_value_type = std_iterator_traits;
pub type std_move_iterator_difference_type = std_iterator_traits;
pub type std_move_iterator_pointer<_Iter> = std_move_iterator_iterator_type<_Iter>;
pub type std_move_iterator_iterator_category = std__If;
pub type std_move_iterator_reference = std_iterator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ostreambuf_iterator {
    pub __sbuf_: *mut std_ostreambuf_iterator_streambuf_type,
}
pub type std_ostreambuf_iterator_iterator_category = std_output_iterator_tag;
pub type std_ostreambuf_iterator_value_type = ::std::os::raw::c_void;
pub type std_ostreambuf_iterator_difference_type = ::std::os::raw::c_void;
pub type std_ostreambuf_iterator_pointer = ::std::os::raw::c_void;
pub type std_ostreambuf_iterator_reference = ::std::os::raw::c_void;
pub type std_ostreambuf_iterator_char_type<_CharT> = _CharT;
pub type std_ostreambuf_iterator_traits_type<_Traits> = _Traits;
pub type std_ostreambuf_iterator_streambuf_type = std_basic_streambuf;
pub type std_ostreambuf_iterator_ostream_type = std_basic_ostream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ostream_iterator<_CharT> {
    pub __out_stream_: *mut std_ostream_iterator_ostream_type,
    pub __delim_: *const std_ostream_iterator_char_type<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_ostream_iterator_iterator_category = std_output_iterator_tag;
pub type std_ostream_iterator_value_type = ::std::os::raw::c_void;
pub type std_ostream_iterator_difference_type = ::std::os::raw::c_void;
pub type std_ostream_iterator_pointer = ::std::os::raw::c_void;
pub type std_ostream_iterator_reference = ::std::os::raw::c_void;
pub type std_ostream_iterator_char_type<_CharT> = _CharT;
pub type std_ostream_iterator_traits_type<_Traits> = _Traits;
pub type std_ostream_iterator_ostream_type = std_basic_ostream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_stashing_iterator {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iter> {
    pub __t: _Iter,
    pub current: _Iter,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iter>>,
}
pub type std_reverse_iterator_iterator_type<_Iter> = _Iter;
pub type std_reverse_iterator_difference_type = std_iterator_traits;
pub type std_reverse_iterator_reference = std_iterator_traits;
pub type std_reverse_iterator_pointer = std_iterator_traits;
pub type std_reverse_iterator_iterator_category = std__If;
pub type std_reverse_iterator_value_type = std_iterator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___wrap_iter<_Iter> {
    pub __i: std___wrap_iter_iterator_type<_Iter>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iter>>,
}
pub type std___wrap_iter_iterator_type<_Iter> = _Iter;
pub type std___wrap_iter_value_type = std_iterator_traits;
pub type std___wrap_iter_difference_type = std_iterator_traits;
pub type std___wrap_iter_pointer = std_iterator_traits;
pub type std___wrap_iter_reference = std_iterator_traits;
pub type std___wrap_iter_iterator_category = std_iterator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_raw_storage_iterator<_OutputIterator> {
    pub __x_: _OutputIterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_OutputIterator>>,
}
pub type std_raw_storage_iterator_iterator_category = std_output_iterator_tag;
pub type std_raw_storage_iterator_value_type = ::std::os::raw::c_void;
pub type std_raw_storage_iterator_difference_type = ::std::os::raw::c_void;
pub type std_raw_storage_iterator_pointer = ::std::os::raw::c_void;
pub type std_raw_storage_iterator_reference = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___return_temporary_buffer {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___return_temporary_buffer() {
    assert_eq!(
        ::std::mem::size_of::<std___return_temporary_buffer>(),
        1usize,
        concat!("Size of: ", stringify!(std___return_temporary_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<std___return_temporary_buffer>(),
        1usize,
        concat!("Alignment of ", stringify!(std___return_temporary_buffer))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___destruct_n {
    pub __size_: size_t,
}
#[test]
fn bindgen_test_layout_std___destruct_n() {
    assert_eq!(
        ::std::mem::size_of::<std___destruct_n>(),
        8usize,
        concat!("Size of: ", stringify!(std___destruct_n))
    );
    assert_eq!(
        ::std::mem::align_of::<std___destruct_n>(),
        8usize,
        concat!("Alignment of ", stringify!(std___destruct_n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std___destruct_n>())).__size_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___destruct_n),
            "::",
            stringify!(__size_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__15alignEmmRPvRm"]
    pub fn std_align(
        __align: size_t,
        __sz: size_t,
        __ptr: *mut *mut ::std::os::raw::c_void,
        __space: *mut size_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___noexcept_move_assign_container {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std___temp_value<_Alloc> {
    pub __v: u8,
    pub __a: *mut _Alloc,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
}
pub type std___temp_value__Traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_allocator {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___builtin_new_allocator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___builtin_new_allocator___builtin_new_deleter {
    pub __size_: size_t,
    pub __align_: size_t,
}
pub type std___builtin_new_allocator___builtin_new_deleter_pointer_type =
    *mut ::std::os::raw::c_void;
#[test]
fn bindgen_test_layout_std___builtin_new_allocator___builtin_new_deleter() {
    assert_eq!(
        ::std::mem::size_of::<std___builtin_new_allocator___builtin_new_deleter>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(std___builtin_new_allocator___builtin_new_deleter)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___builtin_new_allocator___builtin_new_deleter>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std___builtin_new_allocator___builtin_new_deleter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std___builtin_new_allocator___builtin_new_deleter>())).__size_
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___builtin_new_allocator___builtin_new_deleter),
            "::",
            stringify!(__size_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std___builtin_new_allocator___builtin_new_deleter>())).__align_
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std___builtin_new_allocator___builtin_new_deleter),
            "::",
            stringify!(__align_)
        )
    );
}
pub type std___builtin_new_allocator___holder_t = std_unique_ptr;
#[test]
fn bindgen_test_layout_std___builtin_new_allocator() {
    assert_eq!(
        ::std::mem::size_of::<std___builtin_new_allocator>(),
        1usize,
        concat!("Size of: ", stringify!(std___builtin_new_allocator))
    );
    assert_eq!(
        ::std::mem::align_of::<std___builtin_new_allocator>(),
        1usize,
        concat!("Alignment of ", stringify!(std___builtin_new_allocator))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_function_call {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_function_call() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_function_call>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_function_call))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_function_call>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_function_call))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___function___maybe_derive_from_unary_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___function___maybe_derive_from_binary_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___function___base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___function___func {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___mem_fn<_Tp> {
    pub __f_: std___mem_fn_type<_Tp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std___mem_fn_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun_t<_Sp> {
    pub __p_: ::std::option::Option<unsafe extern "C" fn() -> _Sp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sp>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun1_t<_Sp, _Ap> {
    pub __p_: ::std::option::Option<unsafe extern "C" fn(arg1: _Ap) -> _Sp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sp>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ap>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun_ref_t<_Sp> {
    pub __p_: ::std::option::Option<unsafe extern "C" fn() -> _Sp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sp>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun1_ref_t<_Sp, _Ap> {
    pub __p_: ::std::option::Option<unsafe extern "C" fn(arg1: _Ap) -> _Sp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sp>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ap>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun_t<_Sp> {
    pub __p_: ::std::option::Option<unsafe extern "C" fn() -> _Sp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sp>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun1_t<_Sp, _Ap> {
    pub __p_: ::std::option::Option<unsafe extern "C" fn(arg1: _Ap) -> _Sp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sp>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ap>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun_ref_t<_Sp> {
    pub __p_: ::std::option::Option<unsafe extern "C" fn() -> _Sp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sp>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun1_ref_t<_Sp, _Ap> {
    pub __p_: ::std::option::Option<unsafe extern "C" fn(arg1: _Ap) -> _Sp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sp>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ap>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_to_binary_function<_Arg1, _Arg2, _Result> {
    pub __f_: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg1, arg2: _Arg2) -> _Result>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg1>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg2>>,
    pub _phantom_2: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Result>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_to_unary_function<_Arg, _Result> {
    pub __f_: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Result>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Result>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unary_negate<_Predicate> {
    pub __pred_: _Predicate,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___comp_ref_type {
    pub _address: u8,
}
pub type std___comp_ref_type_type = std_add_lvalue_reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invert<_Predicate> {
    pub __p_: _Predicate,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
}
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___log2_imp_value: size_t;
}
#[repr(C)]
pub struct std___independent_bits_engine<_Engine> {
    pub __e_: *mut _Engine,
    pub __w_: size_t,
    pub __w0_: size_t,
    pub __n_: size_t,
    pub __n0_: size_t,
    pub __y0_: std___independent_bits_engine__Working_result_type,
    pub __y1_: std___independent_bits_engine__Working_result_type,
    pub __mask0_: std___independent_bits_engine__Engine_result_type,
    pub __mask1_: std___independent_bits_engine__Engine_result_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Engine>>,
}
pub type std___independent_bits_engine_result_type<_UIntType> = _UIntType;
pub type std___independent_bits_engine__Engine_result_type = [u8; 0usize];
pub type std___independent_bits_engine__Working_result_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uniform_int_distribution<_IntType> {
    pub __p_: std_uniform_int_distribution_param_type<_IntType>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_IntType>>,
}
pub type std_uniform_int_distribution_result_type<_IntType> = _IntType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uniform_int_distribution_param_type<_IntType> {
    pub __a_: std_uniform_int_distribution_result_type<_IntType>,
    pub __b_: std_uniform_int_distribution_result_type<_IntType>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_IntType>>,
}
pub type std_uniform_int_distribution_param_type_distribution_type<_IntType> =
    std_uniform_int_distribution<_IntType>;
extern "C" {
    #[link_name = "\u{1}__ZNSt3__18__rs_getEv"]
    pub fn std___rs_get() -> std___rs_default;
}
#[repr(C)]
#[derive(Debug)]
pub struct std___rs_default {
    pub _address: u8,
}
pub type std___rs_default_result_type = uint_fast32_t;
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112__rs_default4__c_E"]
    pub static mut std___rs_default___c_: ::std::os::raw::c_uint;
}
pub const std___rs_default__Min: std___rs_default_result_type = 0;
pub const std___rs_default__Max: std___rs_default_result_type = 4294967295;
#[test]
fn bindgen_test_layout_std___rs_default() {
    assert_eq!(
        ::std::mem::size_of::<std___rs_default>(),
        1usize,
        concat!("Size of: ", stringify!(std___rs_default))
    );
    assert_eq!(
        ::std::mem::align_of::<std___rs_default>(),
        1usize,
        concat!("Alignment of ", stringify!(std___rs_default))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112__rs_defaultC1ERKS0_"]
    pub fn std___rs_default___rs_default(
        this: *mut std___rs_default,
        arg1: *const std___rs_default,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__112__rs_defaultD1Ev"]
    pub fn std___rs_default___rs_default_destructor(this: *mut std___rs_default);
}
impl std___rs_default {
    #[inline]
    pub unsafe fn new(arg1: *const std___rs_default) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___rs_default___rs_default(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std___rs_default___rs_default_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___stable_sort_switch {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___list_node_pointer_traits {
    pub _address: u8,
}
pub type std___list_node_pointer_traits___node_pointer = std___rebind_pointer;
pub type std___list_node_pointer_traits___base_pointer = std___rebind_pointer;
pub type std___list_node_pointer_traits___link_pointer = u8;
pub type std___list_node_pointer_traits___non_link_pointer = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___list_node_base {
    pub __prev_: std___list_node_base___link_pointer,
    pub __next_: std___list_node_base___link_pointer,
}
pub type std___list_node_base__NodeTraits = std___list_node_pointer_traits;
pub type std___list_node_base___node_pointer = std___list_node_base__NodeTraits;
pub type std___list_node_base___base_pointer = std___list_node_base__NodeTraits;
pub type std___list_node_base___link_pointer = std___list_node_base__NodeTraits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___list_node<_Tp> {
    pub _base: std___list_node_base,
    pub __value_: _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std___list_node___base = std___list_node_base;
pub type std___list_node___link_pointer = std___list_node___base;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___list_iterator {
    pub __ptr_: std___list_iterator___link_pointer,
}
pub type std___list_iterator__NodeTraits = std___list_node_pointer_traits;
pub type std___list_iterator___link_pointer = std___list_iterator__NodeTraits;
pub type std___list_iterator_iterator_category = std_bidirectional_iterator_tag;
pub type std___list_iterator_value_type<_Tp> = _Tp;
pub type std___list_iterator_reference<_Tp> = *mut std___list_iterator_value_type<_Tp>;
pub type std___list_iterator_pointer = std___rebind_pointer;
pub type std___list_iterator_difference_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___list_const_iterator {
    pub __ptr_: std___list_const_iterator___link_pointer,
}
pub type std___list_const_iterator__NodeTraits = std___list_node_pointer_traits;
pub type std___list_const_iterator___link_pointer = std___list_const_iterator__NodeTraits;
pub type std___list_const_iterator_iterator_category = std_bidirectional_iterator_tag;
pub type std___list_const_iterator_value_type<_Tp> = _Tp;
pub type std___list_const_iterator_reference<_Tp> =
    *const std___list_const_iterator_value_type<_Tp>;
pub type std___list_const_iterator_pointer = std___rebind_pointer;
pub type std___list_const_iterator_difference_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug)]
pub struct std___list_imp {
    pub __end_: std___list_imp___node_base,
    pub __size_alloc_: std___compressed_pair,
}
pub type std___list_imp_allocator_type<_Alloc> = _Alloc;
pub type std___list_imp___alloc_traits = std_allocator_traits;
pub type std___list_imp_size_type = std___list_imp___alloc_traits;
pub type std___list_imp_value_type<_Tp> = _Tp;
pub type std___list_imp___void_pointer = std___list_imp___alloc_traits;
pub type std___list_imp_iterator = std___list_iterator;
pub type std___list_imp_const_iterator = std___list_const_iterator;
pub type std___list_imp___node_base = std___list_node_base;
pub type std___list_imp___node<_Tp> = std___list_node<std___list_imp_value_type<_Tp>>;
pub type std___list_imp___node_allocator = std___rebind_alloc_helper;
pub type std___list_imp___node_alloc_traits = std_allocator_traits;
pub type std___list_imp___node_pointer = std___list_imp___node_alloc_traits;
pub type std___list_imp___node_const_pointer = std___list_imp___node_alloc_traits;
pub type std___list_imp___node_pointer_traits = std___list_node_pointer_traits;
pub type std___list_imp___link_pointer = std___list_imp___node_pointer_traits;
pub type std___list_imp___link_const_pointer = std___list_imp___link_pointer;
pub type std___list_imp_pointer = std___list_imp___alloc_traits;
pub type std___list_imp_const_pointer = std___list_imp___alloc_traits;
pub type std___list_imp_difference_type = std___list_imp___alloc_traits;
pub type std___list_imp___node_base_allocator = std___rebind_alloc_helper;
pub type std___list_imp___node_base_pointer = std_allocator_traits;
#[repr(C)]
#[derive(Debug)]
pub struct std_list {
    pub _base: std___list_imp,
}
pub type std_list_base = std___list_imp;
pub type std_list___node = std_list_base;
pub type std_list___node_allocator = std_list_base;
pub type std_list___node_pointer = std_list_base;
pub type std_list___node_alloc_traits = std_list_base;
pub type std_list___node_base = std_list_base;
pub type std_list___node_base_pointer = std_list_base;
pub type std_list___link_pointer = std_list_base;
pub type std_list_value_type<_Tp> = _Tp;
pub type std_list_allocator_type<_Alloc> = _Alloc;
pub type std_list_reference<_Tp> = *mut std_list_value_type<_Tp>;
pub type std_list_const_reference<_Tp> = *const std_list_value_type<_Tp>;
pub type std_list_pointer = std_list_base;
pub type std_list_const_pointer = std_list_base;
pub type std_list_size_type = std_list_base;
pub type std_list_difference_type = std_list_base;
pub type std_list_iterator = std_list_base;
pub type std_list_const_iterator = std_list_base;
pub type std_list_reverse_iterator = std_reverse_iterator<std_list_iterator>;
pub type std_list_const_reverse_iterator = std_reverse_iterator<std_list_const_iterator>;
pub type std_list___remove_return_type = ::std::os::raw::c_void;
pub type std_list___node_destructor = std___allocator_destructor<std_list___node_allocator>;
pub type std_list___hold_pointer = std_unique_ptr;
#[repr(C)]
pub struct std_exception__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_exception {
    pub vtable_: *const std_exception__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_std_exception() {
    assert_eq!(
        ::std::mem::size_of::<std_exception>(),
        8usize,
        concat!("Size of: ", stringify!(std_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<std_exception>(),
        8usize,
        concat!("Alignment of ", stringify!(std_exception))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt9exceptionD1Ev"]
    pub fn std_exception_exception_destructor(this: *mut std_exception);
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt9exception4whatEv"]
    pub fn std_exception_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_exception {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_exception() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_exception>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_exception>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_exception))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt13bad_exceptionD1Ev"]
    pub fn std_bad_exception_bad_exception_destructor(this: *mut std_bad_exception);
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt13bad_exception4whatEv"]
    pub fn std_bad_exception_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
pub type std_unexpected_handler = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "\u{1}__ZSt14set_unexpectedPFvvE"]
    pub fn std_set_unexpected(arg1: std_unexpected_handler) -> std_unexpected_handler;
}
extern "C" {
    #[link_name = "\u{1}__ZSt14get_unexpectedv"]
    pub fn std_get_unexpected() -> std_unexpected_handler;
}
extern "C" {
    #[link_name = "\u{1}__ZSt10unexpectedv"]
    pub fn std_unexpected();
}
pub type std_terminate_handler = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "\u{1}__ZSt13set_terminatePFvvE"]
    pub fn std_set_terminate(arg1: std_terminate_handler) -> std_terminate_handler;
}
extern "C" {
    #[link_name = "\u{1}__ZSt13get_terminatev"]
    pub fn std_get_terminate() -> std_terminate_handler;
}
extern "C" {
    #[link_name = "\u{1}__ZSt9terminatev"]
    pub fn std_terminate();
}
extern "C" {
    #[link_name = "\u{1}__ZSt18uncaught_exceptionv"]
    pub fn std_uncaught_exception() -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZSt19uncaught_exceptionsv"]
    pub fn std_uncaught_exceptions() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZSt17current_exceptionv"]
    pub fn std_current_exception() -> std_exception_ptr;
}
extern "C" {
    #[link_name = "\u{1}__ZSt17rethrow_exceptionSt13exception_ptr"]
    pub fn std_rethrow_exception(arg1: std_exception_ptr);
}
#[repr(C)]
#[derive(Debug)]
pub struct std_exception_ptr {
    pub __ptr_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_std_exception_ptr() {
    assert_eq!(
        ::std::mem::size_of::<std_exception_ptr>(),
        8usize,
        concat!("Size of: ", stringify!(std_exception_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<std_exception_ptr>(),
        8usize,
        concat!("Alignment of ", stringify!(std_exception_ptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_exception_ptr>())).__ptr_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_exception_ptr),
            "::",
            stringify!(__ptr_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt13exception_ptrC1ERKS_"]
    pub fn std_exception_ptr_exception_ptr(
        this: *mut std_exception_ptr,
        arg1: *const std_exception_ptr,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt13exception_ptrD1Ev"]
    pub fn std_exception_ptr_exception_ptr_destructor(this: *mut std_exception_ptr);
}
impl std_exception_ptr {
    #[inline]
    pub unsafe fn new(arg1: *const std_exception_ptr) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_exception_ptr_exception_ptr(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_exception_ptr_exception_ptr_destructor(self)
    }
}
#[repr(C)]
pub struct std_nested_exception__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_nested_exception {
    pub vtable_: *const std_nested_exception__bindgen_vtable,
    pub __ptr_: std_exception_ptr,
}
#[test]
fn bindgen_test_layout_std_nested_exception() {
    assert_eq!(
        ::std::mem::size_of::<std_nested_exception>(),
        16usize,
        concat!("Size of: ", stringify!(std_nested_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<std_nested_exception>(),
        8usize,
        concat!("Alignment of ", stringify!(std_nested_exception))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_nested_exception>())).__ptr_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_nested_exception),
            "::",
            stringify!(__ptr_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt16nested_exception14rethrow_nestedEv"]
    pub fn std_nested_exception_rethrow_nested(this: *const std_nested_exception);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt16nested_exceptionC1Ev"]
    pub fn std_nested_exception_nested_exception(this: *mut std_nested_exception);
}
impl std_nested_exception {
    #[inline]
    pub unsafe fn rethrow_nested(&self) {
        std_nested_exception_rethrow_nested(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_nested_exception_nested_exception(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt16nested_exceptionD1Ev"]
    pub fn std_nested_exception_nested_exception_destructor(this: *mut std_nested_exception);
}
#[repr(C)]
#[derive(Debug)]
pub struct std___nested<_Tp> {
    pub _base: _Tp,
    pub _base_1: std_nested_exception,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___can_dynamic_cast {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_nothrow_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_nothrow_t() {
    assert_eq!(
        ::std::mem::size_of::<std_nothrow_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_nothrow_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_nothrow_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_nothrow_t))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZSt7nothrow"]
    pub static std_nothrow: std_nothrow_t;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_alloc {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_alloc() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_alloc>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_alloc))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_alloc>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_alloc))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt9bad_allocC1Ev"]
    pub fn std_bad_alloc_bad_alloc(this: *mut std_bad_alloc);
}
impl std_bad_alloc {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_bad_alloc_bad_alloc(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt9bad_allocD1Ev"]
    pub fn std_bad_alloc_bad_alloc_destructor(this: *mut std_bad_alloc);
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt9bad_alloc4whatEv"]
    pub fn std_bad_alloc_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_array_new_length {
    pub _base: std_bad_alloc,
}
#[test]
fn bindgen_test_layout_std_bad_array_new_length() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_array_new_length>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_array_new_length))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_array_new_length>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_array_new_length))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt20bad_array_new_lengthC1Ev"]
    pub fn std_bad_array_new_length_bad_array_new_length(this: *mut std_bad_array_new_length);
}
impl std_bad_array_new_length {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_bad_array_new_length_bad_array_new_length(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt20bad_array_new_lengthD1Ev"]
    pub fn std_bad_array_new_length_bad_array_new_length_destructor(
        this: *mut std_bad_array_new_length,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt20bad_array_new_length4whatEv"]
    pub fn std_bad_array_new_length_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
pub type std_new_handler = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "\u{1}__ZSt15set_new_handlerPFvvE"]
    pub fn std_set_new_handler(arg1: std_new_handler) -> std_new_handler;
}
extern "C" {
    #[link_name = "\u{1}__ZSt15get_new_handlerv"]
    pub fn std_get_new_handler() -> std_new_handler;
}
extern "C" {
    #[link_name = "\u{1}__ZSt17__throw_bad_allocv"]
    pub fn std___throw_bad_alloc();
}
pub const std_align_val_t___zero: std_align_val_t = 0;
pub const std_align_val_t___max: std_align_val_t = 18446744073709551615;
pub type std_align_val_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_info_implementations {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_info_implementations___string_impl_base {
    pub _address: u8,
}
pub type std___type_info_implementations___string_impl_base___type_name_t =
    *const ::std::os::raw::c_char;
#[test]
fn bindgen_test_layout_std___type_info_implementations___string_impl_base() {
    assert_eq!(
        ::std::mem::size_of::<std___type_info_implementations___string_impl_base>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___type_info_implementations___string_impl_base)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___type_info_implementations___string_impl_base>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___type_info_implementations___string_impl_base)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_info_implementations___unique_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___type_info_implementations___unique_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___type_info_implementations___unique_impl>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___type_info_implementations___unique_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___type_info_implementations___unique_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___type_info_implementations___unique_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_info_implementations___non_unique_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___type_info_implementations___non_unique_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___type_info_implementations___non_unique_impl>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___type_info_implementations___non_unique_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___type_info_implementations___non_unique_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___type_info_implementations___non_unique_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_info_implementations___non_unique_arm_rtti_bit_impl {
    pub _address: u8,
}
pub type std___type_info_implementations___non_unique_arm_rtti_bit_impl___type_name_t = usize;
pub type std___type_info_implementations___non_unique_arm_rtti_bit_impl___non_unique_rtti_bit = u8;
#[test]
fn bindgen_test_layout_std___type_info_implementations___non_unique_arm_rtti_bit_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___type_info_implementations___non_unique_arm_rtti_bit_impl>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___type_info_implementations___non_unique_arm_rtti_bit_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___type_info_implementations___non_unique_arm_rtti_bit_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___type_info_implementations___non_unique_arm_rtti_bit_impl)
        )
    );
}
pub type std___type_info_implementations___impl =
    std___type_info_implementations___non_unique_arm_rtti_bit_impl;
#[test]
fn bindgen_test_layout_std___type_info_implementations() {
    assert_eq!(
        ::std::mem::size_of::<std___type_info_implementations>(),
        1usize,
        concat!("Size of: ", stringify!(std___type_info_implementations))
    );
    assert_eq!(
        ::std::mem::align_of::<std___type_info_implementations>(),
        1usize,
        concat!("Alignment of ", stringify!(std___type_info_implementations))
    );
}
#[repr(C)]
pub struct std_type_info__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_type_info {
    pub vtable_: *const std_type_info__bindgen_vtable,
    pub __type_name: std___type_info_implementations___non_unique_arm_rtti_bit_impl___type_name_t,
}
pub type std_type_info___impl = std___type_info_implementations___impl;
#[test]
fn bindgen_test_layout_std_type_info() {
    assert_eq!(
        ::std::mem::size_of::<std_type_info>(),
        16usize,
        concat!("Size of: ", stringify!(std_type_info))
    );
    assert_eq!(
        ::std::mem::align_of::<std_type_info>(),
        8usize,
        concat!("Alignment of ", stringify!(std_type_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_type_info>())).__type_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_type_info),
            "::",
            stringify!(__type_name)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt9type_infoD1Ev"]
    pub fn std_type_info_type_info_destructor(this: *mut std_type_info);
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_cast {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_cast() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_cast>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_cast))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_cast>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_cast))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt8bad_castC1Ev"]
    pub fn std_bad_cast_bad_cast(this: *mut std_bad_cast);
}
impl std_bad_cast {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_bad_cast_bad_cast(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt8bad_castD1Ev"]
    pub fn std_bad_cast_bad_cast_destructor(this: *mut std_bad_cast);
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt8bad_cast4whatEv"]
    pub fn std_bad_cast_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_typeid {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_typeid() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_typeid>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_typeid))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_typeid>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_typeid))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt10bad_typeidC1Ev"]
    pub fn std_bad_typeid_bad_typeid(this: *mut std_bad_typeid);
}
impl std_bad_typeid {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_bad_typeid_bad_typeid(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt10bad_typeidD1Ev"]
    pub fn std_bad_typeid_bad_typeid_destructor(this: *mut std_bad_typeid);
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt10bad_typeid4whatEv"]
    pub fn std_bad_typeid_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_logic_error {
    pub _base: std_exception,
    pub __imp_: std___libcpp_refstring,
}
#[test]
fn bindgen_test_layout_std_logic_error() {
    assert_eq!(
        ::std::mem::size_of::<std_logic_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_logic_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_logic_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_logic_error))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_logic_error>())).__imp_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_logic_error),
            "::",
            stringify!(__imp_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt11logic_errorC1ERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE"]
    pub fn std_logic_error_logic_error(this: *mut std_logic_error, arg1: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt11logic_errorC1EPKc"]
    pub fn std_logic_error_logic_error1(
        this: *mut std_logic_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt11logic_errorC1ERKS_"]
    pub fn std_logic_error_logic_error2(this: *mut std_logic_error, arg1: *const std_logic_error);
}
impl std_logic_error {
    #[inline]
    pub unsafe fn new(arg1: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const std_logic_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt11logic_errorD1Ev"]
    pub fn std_logic_error_logic_error_destructor(this: *mut std_logic_error);
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt11logic_error4whatEv"]
    pub fn std_logic_error_what(this: *mut ::std::os::raw::c_void)
        -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_runtime_error {
    pub _base: std_exception,
    pub __imp_: std___libcpp_refstring,
}
#[test]
fn bindgen_test_layout_std_runtime_error() {
    assert_eq!(
        ::std::mem::size_of::<std_runtime_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_runtime_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_runtime_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_runtime_error))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_runtime_error>())).__imp_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_runtime_error),
            "::",
            stringify!(__imp_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt13runtime_errorC1ERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE"]
    pub fn std_runtime_error_runtime_error(this: *mut std_runtime_error, arg1: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}__ZNSt13runtime_errorC1EPKc"]
    pub fn std_runtime_error_runtime_error1(
        this: *mut std_runtime_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt13runtime_errorC1ERKS_"]
    pub fn std_runtime_error_runtime_error2(
        this: *mut std_runtime_error,
        arg1: *const std_runtime_error,
    );
}
impl std_runtime_error {
    #[inline]
    pub unsafe fn new(arg1: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const std_runtime_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNSt13runtime_errorD1Ev"]
    pub fn std_runtime_error_runtime_error_destructor(this: *mut std_runtime_error);
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt13runtime_error4whatEv"]
    pub fn std_runtime_error_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_domain_error {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_std_domain_error() {
    assert_eq!(
        ::std::mem::size_of::<std_domain_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_domain_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_domain_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_domain_error))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt12domain_errorD1Ev"]
    pub fn std_domain_error_domain_error_destructor(this: *mut std_domain_error);
}
#[repr(C)]
#[derive(Debug)]
pub struct std_invalid_argument {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_std_invalid_argument() {
    assert_eq!(
        ::std::mem::size_of::<std_invalid_argument>(),
        16usize,
        concat!("Size of: ", stringify!(std_invalid_argument))
    );
    assert_eq!(
        ::std::mem::align_of::<std_invalid_argument>(),
        8usize,
        concat!("Alignment of ", stringify!(std_invalid_argument))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt16invalid_argumentD1Ev"]
    pub fn std_invalid_argument_invalid_argument_destructor(this: *mut std_invalid_argument);
}
#[repr(C)]
#[derive(Debug)]
pub struct std_length_error {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_std_length_error() {
    assert_eq!(
        ::std::mem::size_of::<std_length_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_length_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_length_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_length_error))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt12length_errorD1Ev"]
    pub fn std_length_error_length_error_destructor(this: *mut std_length_error);
}
#[repr(C)]
#[derive(Debug)]
pub struct std_out_of_range {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_std_out_of_range() {
    assert_eq!(
        ::std::mem::size_of::<std_out_of_range>(),
        16usize,
        concat!("Size of: ", stringify!(std_out_of_range))
    );
    assert_eq!(
        ::std::mem::align_of::<std_out_of_range>(),
        8usize,
        concat!("Alignment of ", stringify!(std_out_of_range))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt12out_of_rangeD1Ev"]
    pub fn std_out_of_range_out_of_range_destructor(this: *mut std_out_of_range);
}
#[repr(C)]
#[derive(Debug)]
pub struct std_range_error {
    pub _base: std_runtime_error,
}
#[test]
fn bindgen_test_layout_std_range_error() {
    assert_eq!(
        ::std::mem::size_of::<std_range_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_range_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_range_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_range_error))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt11range_errorD1Ev"]
    pub fn std_range_error_range_error_destructor(this: *mut std_range_error);
}
#[repr(C)]
#[derive(Debug)]
pub struct std_overflow_error {
    pub _base: std_runtime_error,
}
#[test]
fn bindgen_test_layout_std_overflow_error() {
    assert_eq!(
        ::std::mem::size_of::<std_overflow_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_overflow_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_overflow_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_overflow_error))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt14overflow_errorD1Ev"]
    pub fn std_overflow_error_overflow_error_destructor(this: *mut std_overflow_error);
}
#[repr(C)]
#[derive(Debug)]
pub struct std_underflow_error {
    pub _base: std_runtime_error,
}
#[test]
fn bindgen_test_layout_std_underflow_error() {
    assert_eq!(
        ::std::mem::size_of::<std_underflow_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_underflow_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_underflow_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_underflow_error))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt15underflow_errorD1Ev"]
    pub fn std_underflow_error_underflow_error_destructor(this: *mut std_underflow_error);
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_variant_access {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_variant_access() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_variant_access>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_variant_access))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_variant_access>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_variant_access))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNKSt18bad_variant_access4whatEv"]
    pub fn std_bad_variant_access_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
pub type size_t = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU16 {
    pub __val: u16,
}
#[test]
fn bindgen_test_layout__OSUnalignedU16() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU16>(),
        2usize,
        concat!("Size of: ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU16>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSUnalignedU16>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU16),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU32 {
    pub __val: u32,
}
#[test]
fn bindgen_test_layout__OSUnalignedU32() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU32>(),
        4usize,
        concat!("Size of: ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU32>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSUnalignedU32>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU32),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU64 {
    pub __val: u64,
}
#[test]
fn bindgen_test_layout__OSUnalignedU64() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU64>(),
        8usize,
        concat!("Size of: ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU64>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSUnalignedU64>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU64),
            "::",
            stringify!(__val)
        )
    );
}
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type dev_t = __darwin_dev_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type mode_t = __darwin_mode_t;
pub type nlink_t = __uint16_t;
pub type id_t = __darwin_id_t;
pub type pid_t = __darwin_pid_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type uid_t = __darwin_uid_t;
pub type clock_t = __darwin_clock_t;
pub type ssize_t = __darwin_ssize_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type fd_mask = __int32_t;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type sa_family_t = __uint8_t;
pub type socklen_t = __darwin_socklen_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub type sae_associd_t = __uint32_t;
pub type sae_connid_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sa_endpoints {
    pub sae_srcif: ::std::os::raw::c_uint,
    pub sae_srcaddr: *const sockaddr,
    pub sae_srcaddrlen: socklen_t,
    pub sae_dstaddr: *const sockaddr,
    pub sae_dstaddrlen: socklen_t,
}
#[test]
fn bindgen_test_layout_sa_endpoints() {
    assert_eq!(
        ::std::mem::size_of::<sa_endpoints>(),
        40usize,
        concat!("Size of: ", stringify!(sa_endpoints))
    );
    assert_eq!(
        ::std::mem::align_of::<sa_endpoints>(),
        8usize,
        concat!("Alignment of ", stringify!(sa_endpoints))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sa_endpoints>())).sae_srcif as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcif)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sa_endpoints>())).sae_srcaddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sa_endpoints>())).sae_srcaddrlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcaddrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sa_endpoints>())).sae_dstaddr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_dstaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sa_endpoints>())).sae_dstaddrlen as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_dstaddrlen)
        )
    );
}
pub type sa_endpoints_t = sa_endpoints;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_onoff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_linger as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct so_np_extensions {
    pub npx_flags: u_int32_t,
    pub npx_mask: u_int32_t,
}
#[test]
fn bindgen_test_layout_so_np_extensions() {
    assert_eq!(
        ::std::mem::size_of::<so_np_extensions>(),
        8usize,
        concat!("Size of: ", stringify!(so_np_extensions))
    );
    assert_eq!(
        ::std::mem::align_of::<so_np_extensions>(),
        4usize,
        concat!("Alignment of ", stringify!(so_np_extensions))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<so_np_extensions>())).npx_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(so_np_extensions),
            "::",
            stringify!(npx_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<so_np_extensions>())).npx_mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(so_np_extensions),
            "::",
            stringify!(npx_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        1usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockproto {
    pub sp_family: __uint16_t,
    pub sp_protocol: __uint16_t,
}
#[test]
fn bindgen_test_layout_sockproto() {
    assert_eq!(
        ::std::mem::size_of::<sockproto>(),
        4usize,
        concat!("Size of: ", stringify!(sockproto))
    );
    assert_eq!(
        ::std::mem::align_of::<sockproto>(),
        2usize,
        concat!("Alignment of ", stringify!(sockproto))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockproto>())).sp_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockproto),
            "::",
            stringify!(sp_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockproto>())).sp_protocol as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockproto),
            "::",
            stringify!(sp_protocol)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_len: __uint8_t,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::std::os::raw::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::std::os::raw::c_char; 112usize],
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_pad1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_align as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_pad2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_pad2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::std::os::raw::c_int,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        48usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_namelen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iov as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iovlen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_control as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_controllen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        12usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_level as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sf_hdtr {
    pub headers: *mut iovec,
    pub hdr_cnt: ::std::os::raw::c_int,
    pub trailers: *mut iovec,
    pub trl_cnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sf_hdtr() {
    assert_eq!(
        ::std::mem::size_of::<sf_hdtr>(),
        32usize,
        concat!("Size of: ", stringify!(sf_hdtr))
    );
    assert_eq!(
        ::std::mem::align_of::<sf_hdtr>(),
        8usize,
        concat!("Alignment of ", stringify!(sf_hdtr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sf_hdtr>())).headers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(headers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sf_hdtr>())).hdr_cnt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(hdr_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sf_hdtr>())).trailers as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(trailers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sf_hdtr>())).trl_cnt as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(trl_cnt)
        )
    );
}
extern "C" {
    pub fn accept(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn recv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn recvfrom(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
        arg5: *mut sockaddr,
        arg6: *mut socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn recvmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *mut msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn send(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn sendmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *const msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn sendto(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
        arg5: *const sockaddr,
        arg6: socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn setsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_void,
        arg5: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socket(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sendfile(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
        arg4: *mut off_t,
        arg5: *mut sf_hdtr,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pfctlinput(arg1: ::std::os::raw::c_int, arg2: *mut sockaddr);
}
extern "C" {
    pub fn connectx(
        arg1: ::std::os::raw::c_int,
        arg2: *const sa_endpoints_t,
        arg3: sae_associd_t,
        arg4: ::std::os::raw::c_uint,
        arg5: *const iovec,
        arg6: ::std::os::raw::c_uint,
        arg7: *mut size_t,
        arg8: *mut sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn disconnectx(
        arg1: ::std::os::raw::c_int,
        arg2: sae_associd_t,
        arg3: sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACL_FIBER {
    _unused: [u8; 0],
}
pub const acl_fiber_event_t_FIBER_EVENT_T_KERNEL: acl_fiber_event_t = 0;
pub const acl_fiber_event_t_FIBER_EVENT_T_POLL: acl_fiber_event_t = 1;
pub const acl_fiber_event_t_FIBER_EVENT_T_SELECT: acl_fiber_event_t = 2;
pub const acl_fiber_event_t_FIBER_EVENT_T_WMSG: acl_fiber_event_t = 3;
pub type acl_fiber_event_t = ::std::os::raw::c_uint;
#[repr(C)]
pub struct acl_fiber__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Э���ඨ�壬�����\u{8ec}��Ҫ����\u{333}в�ʵ�\u{5b4}��鷽��"]
#[repr(C)]
#[derive(Debug)]
pub struct acl_fiber {
    pub vtable_: *const acl_fiber__bindgen_vtable,
    pub f_: *mut ACL_FIBER,
}
#[test]
fn bindgen_test_layout_acl_fiber() {
    assert_eq!(
        ::std::mem::size_of::<acl_fiber>(),
        16usize,
        concat!("Size of: ", stringify!(acl_fiber))
    );
    assert_eq!(
        ::std::mem::align_of::<acl_fiber>(),
        8usize,
        concat!("Alignment of ", stringify!(acl_fiber))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<acl_fiber>())).f_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(acl_fiber),
            "::",
            stringify!(f_)
        )
    );
}
extern "C" {
    #[doc = " �ڴ���һ��Э��������ҹ������ running Ϊ false ʱ����Ҫ����������"]
    #[doc = " Э�\u{323}�Ȼ����������ص� run ���������ص������ running Ϊ true ʱ��"]
    #[doc = " ���\u{5b9}���� start ����"]
    #[doc = " @param stack_size {size_t} ������Э�\u{336}����ջ��С"]
    #[link_name = "\u{1}__ZN3acl5fiber5startEm"]
    pub fn acl_fiber_start(this: *mut acl_fiber, stack_size: size_t);
}
extern "C" {
    #[doc = " �ڱ�Э������ʱ���ô˺���\u{368}\u{5aa}��Э���˳�"]
    #[doc = " @return {bool} ���� false ��ʾ��Э��δ�������Ѿ��˳�"]
    #[link_name = "\u{1}__ZN3acl5fiber4killEv"]
    pub fn acl_fiber_kill(this: *mut acl_fiber) -> bool;
}
extern "C" {
    #[doc = " �жϵ�ǰЭ���Ƿ�\u{368}\u{5aa}�˳�"]
    #[doc = " @return {bool} ��Э���Ƿ�\u{368}\u{5aa}�˳�"]
    #[link_name = "\u{1}__ZNK3acl5fiber6killedEv"]
    pub fn acl_fiber_killed(this: *const acl_fiber) -> bool;
}
extern "C" {
    #[doc = " �жϵ�ǰ�������е�Э���Ƿ�\u{368}\u{5aa}�˳����÷����� killed ������Ϊ��"]
    #[doc = " killed ���ȱ����� acl::fiber �������У��Ҹ�Э�\u{336}����п����������У�"]
    #[doc = " Ҳ�п��\u{731}����𣬶� self_killed ����Ҫ acl::fiber ����������һ����ʾ"]
    #[doc = " ��ǰ�������е�Э��"]
    #[doc = " @return {bool}"]
    #[link_name = "\u{1}__ZN3acl5fiber11self_killedEv"]
    pub fn acl_fiber_self_killed() -> bool;
}
extern "C" {
    #[doc = " ��ñ�Э�\u{336}���� ID ��"]
    #[doc = " @return {unsigned int}"]
    #[link_name = "\u{1}__ZNK3acl5fiber6get_idEv"]
    pub fn acl_fiber_get_id(this: *const acl_fiber) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " ��õ�ǰ���е�Э�\u{336}���� ID ��"]
    #[doc = " @return {unsigned int}"]
    #[link_name = "\u{1}__ZN3acl5fiber4selfEv"]
    pub fn acl_fiber_self() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " ��õ�ǰЭ����\u{5b4}��ĳ��ϵͳ API ����ʱ�Ĵ����"]
    #[doc = " return {int}"]
    #[link_name = "\u{1}__ZNK3acl5fiber9get_errnoEv"]
    pub fn acl_fiber_get_errno(this: *const acl_fiber) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ���õ�ǰЭ�\u{335}Ĵ����"]
    #[doc = " @param errnum {int}"]
    #[link_name = "\u{1}__ZN3acl5fiber9set_errnoEi"]
    pub fn acl_fiber_set_errno(this: *mut acl_fiber, errnum: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " ��ñ��β����ĳ�����Ϣ"]
    #[doc = " @return {const char*}"]
    #[link_name = "\u{1}__ZN3acl5fiber11last_serrorEv"]
    pub fn acl_fiber_last_serror() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " ��ñ��β����ĳ�����"]
    #[doc = " @return {int}"]
    #[link_name = "\u{1}__ZN3acl5fiber10last_errorEv"]
    pub fn acl_fiber_last_error() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " �����������ת��������Ϣ"]
    #[doc = " @param errnum {int} �����"]
    #[doc = " @param buf {char*} �洢���"]
    #[doc = " @param size {size_t} buf �ռ��С"]
    #[doc = " @return {const char*} buf ��\u{5b7}"]
    #[link_name = "\u{1}__ZN3acl5fiber8strerrorEiPcm"]
    pub fn acl_fiber_strerror(
        errnum: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        size: size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " ��������Ϣ�������\u{5fc}���"]
    #[doc = " @param on {bool} Ϊ true ʱ���ڲ�������Ϣ���������\u{5fc}���"]
    #[link_name = "\u{1}__ZN3acl5fiber11stdout_openEb"]
    pub fn acl_fiber_stdout_open(on: bool);
}
extern "C" {
    #[doc = " ��ʽ����Э�\u{335}����¼��������\u{363}�\u{36c}ʱ����Э�\u{335}�����Ϊ������ģʽ������"]
    #[doc = " ����Э�\u{33a}\u{f2ef1}���ʽ���� schedule �� schedule_with ������Э�\u{335}�����"]
    #[doc = " @param type {fiber_event_t} �¼��������\u{363}��μ���FIBER_EVENT_T_XXX"]
    #[doc = " @param schedule_auto {bool} ��Ϊ true���\u{b4d3d}�Э�\u{336}�������и�Э��"]
    #[doc = "  ����\u{f2ef1}���ʽ���� schedule/schedule_with ���������е�Э�\u{339}��\u{323}���"]
    #[doc = "  �����Զ�����Э�\u{335}������������ڴ���������Э�\u{33a}\u{e3b31}�����ʽ�ص���"]
    #[doc = "  schedule �� schedule_with ��ʽ������Э�\u{335}���������������Э�\u{339}��\u{323}�"]
    #[doc = "  �ڲ�ȱʡ״\u{32c}Ϊ false"]
    #[link_name = "\u{1}__ZN3acl5fiber4initENS_13fiber_event_tEb"]
    pub fn acl_fiber_init(type_: acl_fiber_event_t, schedule_auto: bool);
}
extern "C" {
    #[doc = " ����Э�����еĵ��ȹ���"]
    #[link_name = "\u{1}__ZN3acl5fiber8scheduleEv"]
    pub fn acl_fiber_schedule();
}
extern "C" {
    #[doc = " ����Э�\u{335}���ʱ\u{5b8}���¼��������\u{363}����ñ���������\u{36c}ʱ������ schedule_init"]
    #[doc = " �� schedule ��������"]
    #[doc = " @param type {fiber_event_t} �¼��������\u{363}��μ���FIBER_EVENT_T_XXX"]
    #[link_name = "\u{1}__ZN3acl5fiber13schedule_withENS_13fiber_event_tE"]
    pub fn acl_fiber_schedule_with(type_: acl_fiber_event_t);
}
extern "C" {
    #[doc = " �жϵ�ǰ�\u{7f3}��Ƿ���Э�\u{335}���״\u{32c}"]
    #[doc = " @return {bool}"]
    #[link_name = "\u{1}__ZN3acl5fiber9scheduledEv"]
    pub fn acl_fiber_scheduled() -> bool;
}
extern "C" {
    #[doc = "  \u{363}\u{5b9}Э�\u{335}��ȹ���"]
    #[link_name = "\u{1}__ZN3acl5fiber13schedule_stopEv"]
    pub fn acl_fiber_schedule_stop();
}
extern "C" {
    #[doc = " ����ǰ�������е�Э��(����Э��) ����"]
    #[link_name = "\u{1}__ZN3acl5fiber5yieldEv"]
    pub fn acl_fiber_yield();
}
extern "C" {
    #[doc = " ����ǰЭ�\u{323}�\u{5b4}�еȴ������е���һ��Э��"]
    #[link_name = "\u{1}__ZN3acl5fiber14switch_to_nextEv"]
    pub fn acl_fiber_switch_to_next();
}
extern "C" {
    #[doc = " ��\u{5b8}��Э�\u{336}�����������ж�����"]
    #[doc = " @param f {fiber&}"]
    #[link_name = "\u{1}__ZN3acl5fiber5readyERS0_"]
    pub fn acl_fiber_ready(f: *mut acl_fiber);
}
extern "C" {
    #[doc = " ʹ��ǰ���е�Э������\u{5b8}��������"]
    #[doc = " @param milliseconds {unsigned int} \u{5b8}��Ҫ���ߵĺ�����"]
    #[doc = " @return {unsigned int} ��Э�����ߺ��ٴα����Ѻ�ʣ��ĺ�����"]
    #[link_name = "\u{1}__ZN3acl5fiber5delayEj"]
    pub fn acl_fiber_delay(milliseconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " ��ô��ڴ��״\u{32c}��Э������"]
    #[doc = " @return {unsigned}"]
    #[link_name = "\u{1}__ZN3acl5fiber12alive_numberEv"]
    pub fn acl_fiber_alive_number() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " ��ô����˳�״\u{32c}��Э�\u{336}�������"]
    #[doc = " @return {unsigned}"]
    #[link_name = "\u{1}__ZN3acl5fiber11dead_numberEv"]
    pub fn acl_fiber_dead_number() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " �\u{7f3}���������ô˺������õ�ǰ�\u{7f3}��Ƿ���Ҫ hook ϵͳ API���ڲ�ȱʡ"]
    #[doc = " �� hook ϵͳ API"]
    #[doc = " @param on {bool}"]
    #[link_name = "\u{1}__ZN3acl5fiber8hook_apiEb"]
    pub fn acl_fiber_hook_api(on: bool);
}
extern "C" {
    #[doc = " ���ñ��\u{7f3}�������Э�������ӷ����ʱ�������˴���ʱ�ķ�������ʽ������Windows)"]
    #[doc = " @param yes {bool}"]
    #[link_name = "\u{1}__ZN3acl5fiber16set_non_blockingEb"]
    pub fn acl_fiber_set_non_blocking(yes: bool);
}
extern "C" {
    #[doc = " ��ʽ���ñ�����ʹ acl ������� IO ����Э�\u{33b}����� UNIX ƽ\u{328}�²�����ʽ"]
    #[doc = " ���ñ���������Ϊ�ڲ����Զ� HOOK IO API"]
    #[link_name = "\u{1}__ZN3acl5fiber11acl_io_hookEv"]
    pub fn acl_fiber_acl_io_hook();
}
extern "C" {
    #[doc = " ���ñ�����ȡ�� acl�������е� IO Э�\u{33b}�"]
    #[link_name = "\u{1}__ZN3acl5fiber13acl_io_unlockEv"]
    pub fn acl_fiber_acl_io_unlock();
}
extern "C" {
    #[doc = " Windows ƽ\u{328}�¿�����ʽ�ص��ô˺��� Hook һЩ������Э����ص�ϵͳ API"]
    #[doc = " @return {bool}"]
    #[link_name = "\u{1}__ZN3acl5fiber11winapi_hookEv"]
    pub fn acl_fiber_winapi_hook() -> bool;
}
extern "C" {
    #[doc = " ��õ�ǰϵͳ�������"]
    #[doc = " @return {int}"]
    #[link_name = "\u{1}__ZN3acl5fiber13get_sys_errnoEv"]
    pub fn acl_fiber_get_sys_errno() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ���õ�ǰϵͳ�������"]
    #[doc = " @param errnum {int}"]
    #[link_name = "\u{1}__ZN3acl5fiber13set_sys_errnoEi"]
    pub fn acl_fiber_set_sys_errno(errnum: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " ���ر�Э�\u{336}����Ӧ�� C ���Ե�Э�\u{336}���"]
    #[doc = " @return {ACL_FIBER* }"]
    #[link_name = "\u{1}__ZNK3acl5fiber9get_fiberEv"]
    pub fn acl_fiber_get_fiber(this: *const acl_fiber) -> *mut ACL_FIBER;
}
extern "C" {
    #[doc = " �ײ���� C API ����Э��"]
    #[doc = " @param fn {void (*)(ACL_FIBER*, void*)} Э�\u{33a}���\u{5b4}�����"]
    #[doc = " @param ctx {void*} ���ݸ�Э��\u{5b4}�к����Ĳ���"]
    #[doc = " @param size {size_t} Э��ջ��С"]
    #[link_name = "\u{1}__ZN3acl5fiber12fiber_createEPFvP9ACL_FIBERPvES3_m"]
    pub fn acl_fiber_fiber_create(
        fn_: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ACL_FIBER, arg2: *mut ::std::os::raw::c_void),
        >,
        ctx: *mut ::std::os::raw::c_void,
        size: size_t,
    );
}
extern "C" {
    #[doc = " ���캯��"]
    #[doc = " @param running {bool} ��Ϊ true ʱ�����ʾ��ǰЭ������������������"]
    #[doc = "  ��һ��Э�\u{336}�����ѣ��Ա����� ACL_FIBER ����\u{f6a23}���ʱ��\u{5b9}���ñ���"]
    #[doc = "  ��� start ����������Э��; ��Ϊ false ʱ������Ҫ���� start ������"]
    #[doc = "  ������Э��"]
    #[link_name = "\u{1}__ZN3acl5fiberC1Eb"]
    pub fn acl_fiber_fiber(this: *mut acl_fiber, running: bool);
}
impl acl_fiber {
    #[inline]
    pub unsafe fn start(&mut self, stack_size: size_t) {
        acl_fiber_start(self, stack_size)
    }
    #[inline]
    pub unsafe fn kill(&mut self) -> bool {
        acl_fiber_kill(self)
    }
    #[inline]
    pub unsafe fn killed(&self) -> bool {
        acl_fiber_killed(self)
    }
    #[inline]
    pub unsafe fn self_killed() -> bool {
        acl_fiber_self_killed()
    }
    #[inline]
    pub unsafe fn get_id(&self) -> ::std::os::raw::c_uint {
        acl_fiber_get_id(self)
    }
    #[inline]
    pub unsafe fn self_() -> ::std::os::raw::c_uint {
        acl_fiber_self()
    }
    #[inline]
    pub unsafe fn get_errno(&self) -> ::std::os::raw::c_int {
        acl_fiber_get_errno(self)
    }
    #[inline]
    pub unsafe fn set_errno(&mut self, errnum: ::std::os::raw::c_int) {
        acl_fiber_set_errno(self, errnum)
    }
    #[inline]
    pub unsafe fn last_serror() -> *const ::std::os::raw::c_char {
        acl_fiber_last_serror()
    }
    #[inline]
    pub unsafe fn last_error() -> ::std::os::raw::c_int {
        acl_fiber_last_error()
    }
    #[inline]
    pub unsafe fn strerror(
        errnum: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        size: size_t,
    ) -> *const ::std::os::raw::c_char {
        acl_fiber_strerror(errnum, buf, size)
    }
    #[inline]
    pub unsafe fn stdout_open(on: bool) {
        acl_fiber_stdout_open(on)
    }
    #[inline]
    pub unsafe fn init(type_: acl_fiber_event_t, schedule_auto: bool) {
        acl_fiber_init(type_, schedule_auto)
    }
    #[inline]
    pub unsafe fn schedule() {
        acl_fiber_schedule()
    }
    #[inline]
    pub unsafe fn schedule_with(type_: acl_fiber_event_t) {
        acl_fiber_schedule_with(type_)
    }
    #[inline]
    pub unsafe fn scheduled() -> bool {
        acl_fiber_scheduled()
    }
    #[inline]
    pub unsafe fn schedule_stop() {
        acl_fiber_schedule_stop()
    }
    #[inline]
    pub unsafe fn yield_() {
        acl_fiber_yield()
    }
    #[inline]
    pub unsafe fn switch_to_next() {
        acl_fiber_switch_to_next()
    }
    #[inline]
    pub unsafe fn ready(f: *mut acl_fiber) {
        acl_fiber_ready(f)
    }
    #[inline]
    pub unsafe fn delay(milliseconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint {
        acl_fiber_delay(milliseconds)
    }
    #[inline]
    pub unsafe fn alive_number() -> ::std::os::raw::c_uint {
        acl_fiber_alive_number()
    }
    #[inline]
    pub unsafe fn dead_number() -> ::std::os::raw::c_uint {
        acl_fiber_dead_number()
    }
    #[inline]
    pub unsafe fn hook_api(on: bool) {
        acl_fiber_hook_api(on)
    }
    #[inline]
    pub unsafe fn set_non_blocking(yes: bool) {
        acl_fiber_set_non_blocking(yes)
    }
    #[inline]
    pub unsafe fn acl_io_hook() {
        acl_fiber_acl_io_hook()
    }
    #[inline]
    pub unsafe fn acl_io_unlock() {
        acl_fiber_acl_io_unlock()
    }
    #[inline]
    pub unsafe fn winapi_hook() -> bool {
        acl_fiber_winapi_hook()
    }
    #[inline]
    pub unsafe fn get_sys_errno() -> ::std::os::raw::c_int {
        acl_fiber_get_sys_errno()
    }
    #[inline]
    pub unsafe fn set_sys_errno(errnum: ::std::os::raw::c_int) {
        acl_fiber_set_sys_errno(errnum)
    }
    #[inline]
    pub unsafe fn get_fiber(&self) -> *mut ACL_FIBER {
        acl_fiber_get_fiber(self)
    }
    #[inline]
    pub unsafe fn fiber_create(
        fn_: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ACL_FIBER, arg2: *mut ::std::os::raw::c_void),
        >,
        ctx: *mut ::std::os::raw::c_void,
        size: size_t,
    ) {
        acl_fiber_fiber_create(fn_, ctx, size)
    }
    #[inline]
    pub unsafe fn new(running: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        acl_fiber_fiber(__bindgen_tmp.as_mut_ptr(), running);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN3acl5fiberD1Ev"]
    pub fn acl_fiber_fiber_destructor(this: *mut acl_fiber);
}
extern "C" {
    #[doc = " �麯����������ʵ�\u{5b1}���������\u{368}������ start ��������Э�\u{33a}\u{e3b31}�"]
    #[doc = " �麯�����ᱻ���ã��Ӷ�\u{368}\u{5aa}����Э��������; ����ڹ��캯���еĲ���"]
    #[doc = " running Ϊ true ���� start ������\u{5b9}���ã��ʱ��鷽��Ҳ���ᱻ����"]
    #[link_name = "\u{1}__ZN3acl5fiber3runEv"]
    pub fn acl_fiber_run(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
pub struct acl_fiber_timer__bindgen_vtable(::std::os::raw::c_void);
#[doc = " ��������ʱ����Э����"]
#[repr(C)]
#[derive(Debug)]
pub struct acl_fiber_timer {
    pub vtable_: *const acl_fiber_timer__bindgen_vtable,
    pub f_: *mut ACL_FIBER,
}
#[test]
fn bindgen_test_layout_acl_fiber_timer() {
    assert_eq!(
        ::std::mem::size_of::<acl_fiber_timer>(),
        16usize,
        concat!("Size of: ", stringify!(acl_fiber_timer))
    );
    assert_eq!(
        ::std::mem::align_of::<acl_fiber_timer>(),
        8usize,
        concat!("Alignment of ", stringify!(acl_fiber_timer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<acl_fiber_timer>())).f_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(acl_fiber_timer),
            "::",
            stringify!(f_)
        )
    );
}
extern "C" {
    #[doc = " ����һ��Э�\u{336}�ʱ��"]
    #[doc = " @param milliseconds {unsigned int} ���뼶ʱ��"]
    #[doc = " @param stack_size {size_t} Э�\u{335}�ջ�ռ��С"]
    #[link_name = "\u{1}__ZN3acl11fiber_timer5startEjm"]
    pub fn acl_fiber_timer_start(
        this: *mut acl_fiber_timer,
        milliseconds: ::std::os::raw::c_uint,
        stack_size: size_t,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN3acl11fiber_timerC2Ev"]
    pub fn acl_fiber_timer_fiber_timer(this: *mut acl_fiber_timer);
}
impl acl_fiber_timer {
    #[inline]
    pub unsafe fn start(&mut self, milliseconds: ::std::os::raw::c_uint, stack_size: size_t) {
        acl_fiber_timer_start(self, milliseconds, stack_size)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        acl_fiber_timer_fiber_timer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[doc = " ��������\u{36c}һ�\u{7f3}��ڲ���Э��\u{5ae}����л���Ļ�����"]
#[repr(C)]
#[derive(Debug)]
pub struct acl_fiber_mutex {
    pub lock_: *mut ACL_FIBER_MUTEX,
}
#[test]
fn bindgen_test_layout_acl_fiber_mutex() {
    assert_eq!(
        ::std::mem::size_of::<acl_fiber_mutex>(),
        8usize,
        concat!("Size of: ", stringify!(acl_fiber_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<acl_fiber_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(acl_fiber_mutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<acl_fiber_mutex>())).lock_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acl_fiber_mutex),
            "::",
            stringify!(lock_)
        )
    );
}
extern "C" {
    #[doc = " �ȴ�������"]
    #[doc = " @return {bool} ���� true ��ʾ�����ɹ��������ʾ�ڲ�����"]
    #[link_name = "\u{1}__ZN3acl11fiber_mutex4lockEv"]
    pub fn acl_fiber_mutex_lock(this: *mut acl_fiber_mutex) -> bool;
}
extern "C" {
    #[doc = " ���Եȴ�������"]
    #[doc = " @return {bool} ���� true ��ʾ�����ɹ��������ʾ�����ڱ�ռ��"]
    #[link_name = "\u{1}__ZN3acl11fiber_mutex7trylockEv"]
    pub fn acl_fiber_mutex_trylock(this: *mut acl_fiber_mutex) -> bool;
}
extern "C" {
    #[doc = " ������ӵ�����ͷ�����\u{368}\u{5aa}�ȴ���"]
    #[doc = " @return {bool} ���� true ��ʾ\u{368}\u{5aa}�ɹ��������ʾ�ڲ�����"]
    #[link_name = "\u{1}__ZN3acl11fiber_mutex6unlockEv"]
    pub fn acl_fiber_mutex_unlock(this: *mut acl_fiber_mutex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN3acl11fiber_mutexC1Ev"]
    pub fn acl_fiber_mutex_fiber_mutex(this: *mut acl_fiber_mutex);
}
extern "C" {
    #[link_name = "\u{1}__ZN3acl11fiber_mutexD1Ev"]
    pub fn acl_fiber_mutex_fiber_mutex_destructor(this: *mut acl_fiber_mutex);
}
impl acl_fiber_mutex {
    #[inline]
    pub unsafe fn lock(&mut self) -> bool {
        acl_fiber_mutex_lock(self)
    }
    #[inline]
    pub unsafe fn trylock(&mut self) -> bool {
        acl_fiber_mutex_trylock(self)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) -> bool {
        acl_fiber_mutex_unlock(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        acl_fiber_mutex_fiber_mutex(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        acl_fiber_mutex_fiber_mutex_destructor(self)
    }
}
#[doc = " ��������\u{36c}һ�\u{7f3}��ڵ�Э��\u{5ae}����л���Ķ�д��"]
#[repr(C)]
#[derive(Debug)]
pub struct acl_fiber_rwlock {
    pub rwlk_: *mut ACL_FIBER_RWLOCK,
}
#[test]
fn bindgen_test_layout_acl_fiber_rwlock() {
    assert_eq!(
        ::std::mem::size_of::<acl_fiber_rwlock>(),
        8usize,
        concat!("Size of: ", stringify!(acl_fiber_rwlock))
    );
    assert_eq!(
        ::std::mem::align_of::<acl_fiber_rwlock>(),
        8usize,
        concat!("Alignment of ", stringify!(acl_fiber_rwlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<acl_fiber_rwlock>())).rwlk_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acl_fiber_rwlock),
            "::",
            stringify!(rwlk_)
        )
    );
}
extern "C" {
    #[doc = " �Ӷ���"]
    #[link_name = "\u{1}__ZN3acl12fiber_rwlock5rlockEv"]
    pub fn acl_fiber_rwlock_rlock(this: *mut acl_fiber_rwlock);
}
extern "C" {
    #[doc = " ���ԼӶ���"]
    #[doc = " @return {bool} ���� true ��ʾ�����ɹ��������ʾ�����ڱ�ռ��"]
    #[link_name = "\u{1}__ZN3acl12fiber_rwlock8tryrlockEv"]
    pub fn acl_fiber_rwlock_tryrlock(this: *mut acl_fiber_rwlock) -> bool;
}
extern "C" {
    #[doc = " �����"]
    #[link_name = "\u{1}__ZN3acl12fiber_rwlock7runlockEv"]
    pub fn acl_fiber_rwlock_runlock(this: *mut acl_fiber_rwlock);
}
extern "C" {
    #[doc = " ��д��"]
    #[link_name = "\u{1}__ZN3acl12fiber_rwlock5wlockEv"]
    pub fn acl_fiber_rwlock_wlock(this: *mut acl_fiber_rwlock);
}
extern "C" {
    #[doc = " ���Լ�д��"]
    #[doc = " @return {bool} ���� true ��ʾ�����ɹ��������ʾ�����ڱ�ռ��"]
    #[link_name = "\u{1}__ZN3acl12fiber_rwlock8trywlockEv"]
    pub fn acl_fiber_rwlock_trywlock(this: *mut acl_fiber_rwlock) -> bool;
}
extern "C" {
    #[doc = " ��д��"]
    #[link_name = "\u{1}__ZN3acl12fiber_rwlock7wunlockEv"]
    pub fn acl_fiber_rwlock_wunlock(this: *mut acl_fiber_rwlock);
}
extern "C" {
    #[link_name = "\u{1}__ZN3acl12fiber_rwlockC1Ev"]
    pub fn acl_fiber_rwlock_fiber_rwlock(this: *mut acl_fiber_rwlock);
}
extern "C" {
    #[link_name = "\u{1}__ZN3acl12fiber_rwlockD1Ev"]
    pub fn acl_fiber_rwlock_fiber_rwlock_destructor(this: *mut acl_fiber_rwlock);
}
impl acl_fiber_rwlock {
    #[inline]
    pub unsafe fn rlock(&mut self) {
        acl_fiber_rwlock_rlock(self)
    }
    #[inline]
    pub unsafe fn tryrlock(&mut self) -> bool {
        acl_fiber_rwlock_tryrlock(self)
    }
    #[inline]
    pub unsafe fn runlock(&mut self) {
        acl_fiber_rwlock_runlock(self)
    }
    #[inline]
    pub unsafe fn wlock(&mut self) {
        acl_fiber_rwlock_wlock(self)
    }
    #[inline]
    pub unsafe fn trywlock(&mut self) -> bool {
        acl_fiber_rwlock_trywlock(self)
    }
    #[inline]
    pub unsafe fn wunlock(&mut self) {
        acl_fiber_rwlock_wunlock(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        acl_fiber_rwlock_fiber_rwlock(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        acl_fiber_rwlock_fiber_rwlock_destructor(self)
    }
}
#[doc = " ������Э��\u{5ae}�䡢�\u{7f3}�\u{5ae}���Լ�Э�����\u{7f3}�\u{5ae}�䣬\u{368}���¼��ȴ�/\u{368}\u{5aa}��ʽ����\u{36c}����"]
#[doc = " ���¼������"]
#[repr(C)]
#[derive(Debug)]
pub struct acl_fiber_event {
    pub event_: *mut ACL_FIBER_EVENT,
}
#[test]
fn bindgen_test_layout_acl_fiber_event() {
    assert_eq!(
        ::std::mem::size_of::<acl_fiber_event>(),
        8usize,
        concat!("Size of: ", stringify!(acl_fiber_event))
    );
    assert_eq!(
        ::std::mem::align_of::<acl_fiber_event>(),
        8usize,
        concat!("Alignment of ", stringify!(acl_fiber_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<acl_fiber_event>())).event_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acl_fiber_event),
            "::",
            stringify!(event_)
        )
    );
}
extern "C" {
    #[doc = " �ȴ��¼���"]
    #[doc = " @return {bool} ���� true ��ʾ�����ɹ��������ʾ�ڲ�����"]
    #[link_name = "\u{1}__ZN3acl11fiber_event4waitEv"]
    pub fn acl_fiber_event_wait(this: *mut acl_fiber_event) -> bool;
}
extern "C" {
    #[doc = " ���Եȴ��¼���"]
    #[doc = " @return {bool} ���� true ��ʾ�����ɹ��������ʾ�����ڱ�ռ��"]
    #[link_name = "\u{1}__ZN3acl11fiber_event7trywaitEv"]
    pub fn acl_fiber_event_trywait(this: *mut acl_fiber_event) -> bool;
}
extern "C" {
    #[doc = " �¼���ӵ�����ͷ��¼�����\u{368}\u{5aa}�ȴ���"]
    #[doc = " @return {bool} ���� true ��ʾ\u{368}\u{5aa}�ɹ��������ʾ�ڲ�����"]
    #[link_name = "\u{1}__ZN3acl11fiber_event6notifyEv"]
    pub fn acl_fiber_event_notify(this: *mut acl_fiber_event) -> bool;
}
extern "C" {
    #[doc = " ���췽��"]
    #[doc = " @param use_mutex {bool} �����ڶ��\u{7f3}�\u{5ae}������¼�\u{36c}��ʱ�����������"]
    #[doc = "  ���\u{7f3}����϶\u{8e8}�ɰ���ǧ���\u{7f3}\u{323}�����˱�־Ӧ��Ϊ true �Ա����ڲ���"]
    #[doc = "  \u{36c}���ڲ�����ʱʹ���\u{7f3}\u{33b}��������б������Ա����γɾ�Ⱥ�����������"]
    #[doc = "  ���\u{7f3}����϶൫�ñ�־Ϊ false�����ڲ�ʹ��ԭ��������\u{36c}��������������"]
    #[doc = "  ��ɾ�Ⱥ���⣻���������\u{7f3}����ϣ���ʮ�����ң�����˲���������Ϊ false"]
    #[doc = "  �Ը�\u{5ae}�ڲ�ʹ��ԭ��������\u{36c}������"]
    #[doc = " @param fatal_on_error {bool} �ڲ���������ʱ�Ƿ�\u{5b1}�ӱ������Ա��ڿ���"]
    #[doc = "  ��Ա���д������"]
    #[link_name = "\u{1}__ZN3acl11fiber_eventC1Ebb"]
    pub fn acl_fiber_event_fiber_event(
        this: *mut acl_fiber_event,
        use_mutex: bool,
        fatal_on_error: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN3acl11fiber_eventD1Ev"]
    pub fn acl_fiber_event_fiber_event_destructor(this: *mut acl_fiber_event);
}
impl acl_fiber_event {
    #[inline]
    pub unsafe fn wait(&mut self) -> bool {
        acl_fiber_event_wait(self)
    }
    #[inline]
    pub unsafe fn trywait(&mut self) -> bool {
        acl_fiber_event_trywait(self)
    }
    #[inline]
    pub unsafe fn notify(&mut self) -> bool {
        acl_fiber_event_notify(self)
    }
    #[inline]
    pub unsafe fn new(use_mutex: bool, fatal_on_error: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        acl_fiber_event_fiber_event(__bindgen_tmp.as_mut_ptr(), use_mutex, fatal_on_error);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        acl_fiber_event_fiber_event_destructor(self)
    }
}
#[doc = " ������Э��\u{5ae}�䣬�\u{7f3}�\u{5ae}�䣬Э�����\u{7f3}�\u{5ae}�����������"]
#[repr(C)]
#[derive(Debug)]
pub struct acl_fiber_cond {
    pub cond_: *mut ACL_FIBER_COND,
}
#[test]
fn bindgen_test_layout_acl_fiber_cond() {
    assert_eq!(
        ::std::mem::size_of::<acl_fiber_cond>(),
        8usize,
        concat!("Size of: ", stringify!(acl_fiber_cond))
    );
    assert_eq!(
        ::std::mem::align_of::<acl_fiber_cond>(),
        8usize,
        concat!("Alignment of ", stringify!(acl_fiber_cond))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<acl_fiber_cond>())).cond_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acl_fiber_cond),
            "::",
            stringify!(cond_)
        )
    );
}
extern "C" {
    #[doc = " �ȴ����������¼�������"]
    #[doc = " @param event {fiber_event&}"]
    #[doc = " @param timeout {int} ��ʱ�ȴ�ʱ�䣨���룩"]
    #[doc = " @return {bool} �ɹ�ʱ���� true�����\u{b7d7b}� false ��ʾ��ʱ"]
    #[link_name = "\u{1}__ZN3acl10fiber_cond4waitERNS_11fiber_eventEi"]
    pub fn acl_fiber_cond_wait(
        this: *mut acl_fiber_cond,
        event: *mut acl_fiber_event,
        timeout: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " ���������������ϵĵȴ��ߣ����û�еȴ�����\u{5b1}�ӷ��أ�������Ϊ��"]
    #[doc = " �\u{7f3}�������������"]
    #[doc = " @return {bool} �ɹ����� true�����\u{b7d7b}� false ��ʾʧ��"]
    #[link_name = "\u{1}__ZN3acl10fiber_cond6notifyEv"]
    pub fn acl_fiber_cond_notify(this: *mut acl_fiber_cond) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN3acl10fiber_condC1Ev"]
    pub fn acl_fiber_cond_fiber_cond(this: *mut acl_fiber_cond);
}
extern "C" {
    #[link_name = "\u{1}__ZN3acl10fiber_condD1Ev"]
    pub fn acl_fiber_cond_fiber_cond_destructor(this: *mut acl_fiber_cond);
}
impl acl_fiber_cond {
    #[inline]
    pub unsafe fn wait(
        &mut self,
        event: *mut acl_fiber_event,
        timeout: ::std::os::raw::c_int,
    ) -> bool {
        acl_fiber_cond_wait(self, event, timeout)
    }
    #[inline]
    pub unsafe fn notify(&mut self) -> bool {
        acl_fiber_cond_notify(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        acl_fiber_cond_fiber_cond(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        acl_fiber_cond_fiber_cond_destructor(self)
    }
}
#[doc = " ����Э��\u{5ae}�䣬�\u{7f3}�\u{5ae}���Լ�Э�����\u{7f3}�\u{5ae}�����Ϣ\u{368}�ţ�\u{368}��Э����������"]
#[doc = " ��Э���¼���ʵ��"]
#[doc = ""]
#[doc = " ʾ����"]
#[doc = ""]
#[doc = " class myobj"]
#[doc = " {"]
#[doc = " public:"]
#[doc = "     myobj(void) {}"]
#[doc = "     ~myobj(void) {}"]
#[doc = ""]
#[doc = "     void test(void) { printf(\"hello world\\r\\n\"); }"]
#[doc = " };"]
#[doc = ""]
#[doc = " acl::fiber_tbox<myobj> fiber_tbox;"]
#[doc = ""]
#[doc = " void thread_producer(void)"]
#[doc = " {"]
#[doc = "     myobj* o = new myobj;"]
#[doc = "     fiber_tbox.push(o);"]
#[doc = " }"]
#[doc = ""]
#[doc = " void thread_consumer(void)"]
#[doc = " {"]
#[doc = "     myobj* o = fiber_tbox.pop();"]
#[doc = "     o->test();"]
#[doc = "     delete o;"]
#[doc = " }"]
#[repr(C)]
#[derive(Debug)]
pub struct acl_fiber_tbox {
    pub tbox_: std_list,
    pub size_: size_t,
    pub free_obj_: bool,
    pub event_: acl_fiber_event,
    pub cond_: acl_fiber_cond,
}
#[repr(C)]
#[derive(Debug)]
pub struct acl_fiber_sem {
    pub sem_: *mut ACL_FIBER_SEM,
}
#[test]
fn bindgen_test_layout_acl_fiber_sem() {
    assert_eq!(
        ::std::mem::size_of::<acl_fiber_sem>(),
        8usize,
        concat!("Size of: ", stringify!(acl_fiber_sem))
    );
    assert_eq!(
        ::std::mem::align_of::<acl_fiber_sem>(),
        8usize,
        concat!("Alignment of ", stringify!(acl_fiber_sem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<acl_fiber_sem>())).sem_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acl_fiber_sem),
            "::",
            stringify!(sem_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN3acl9fiber_sem4waitEv"]
    pub fn acl_fiber_sem_wait(this: *mut acl_fiber_sem) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN3acl9fiber_sem7trywaitEv"]
    pub fn acl_fiber_sem_trywait(this: *mut acl_fiber_sem) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN3acl9fiber_sem4postEv"]
    pub fn acl_fiber_sem_post(this: *mut acl_fiber_sem) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN3acl9fiber_semC1Ei"]
    pub fn acl_fiber_sem_fiber_sem(this: *mut acl_fiber_sem, max: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}__ZN3acl9fiber_semD1Ev"]
    pub fn acl_fiber_sem_fiber_sem_destructor(this: *mut acl_fiber_sem);
}
impl acl_fiber_sem {
    #[inline]
    pub unsafe fn wait(&mut self) -> ::std::os::raw::c_int {
        acl_fiber_sem_wait(self)
    }
    #[inline]
    pub unsafe fn trywait(&mut self) -> ::std::os::raw::c_int {
        acl_fiber_sem_trywait(self)
    }
    #[inline]
    pub unsafe fn post(&mut self) -> ::std::os::raw::c_int {
        acl_fiber_sem_post(self)
    }
    #[inline]
    pub unsafe fn new(max: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        acl_fiber_sem_fiber_sem(__bindgen_tmp.as_mut_ptr(), max);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        acl_fiber_sem_fiber_sem_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct acl_fiber_sem_guard {
    pub sem_: *mut acl_fiber_sem,
}
#[test]
fn bindgen_test_layout_acl_fiber_sem_guard() {
    assert_eq!(
        ::std::mem::size_of::<acl_fiber_sem_guard>(),
        8usize,
        concat!("Size of: ", stringify!(acl_fiber_sem_guard))
    );
    assert_eq!(
        ::std::mem::align_of::<acl_fiber_sem_guard>(),
        8usize,
        concat!("Alignment of ", stringify!(acl_fiber_sem_guard))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<acl_fiber_sem_guard>())).sem_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acl_fiber_sem_guard),
            "::",
            stringify!(sem_)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct acl_fiber_sbox {
    pub sem_: acl_fiber_sem,
    pub sbox_: std_list,
    pub size_: size_t,
    pub free_obj_: bool,
}
extern "C" {
    #[link_name = "\u{1}__ZN3acl14channel_createEii"]
    pub fn acl_channel_create(
        elemsize: ::std::os::raw::c_int,
        bufsize: ::std::os::raw::c_int,
    ) -> *mut ACL_CHANNEL;
}
extern "C" {
    #[link_name = "\u{1}__ZN3acl12channel_freeEP11ACL_CHANNEL"]
    pub fn acl_channel_free(c: *mut ACL_CHANNEL);
}
extern "C" {
    #[link_name = "\u{1}__ZN3acl12channel_sendEP11ACL_CHANNELPv"]
    pub fn acl_channel_send(
        c: *mut ACL_CHANNEL,
        v: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN3acl12channel_recvEP11ACL_CHANNELPv"]
    pub fn acl_channel_recv(
        c: *mut ACL_CHANNEL,
        v: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug)]
pub struct acl_channel {
    pub chan_: *mut ACL_CHANNEL,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACL_FIBER_MUTEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACL_FIBER_RWLOCK {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACL_FIBER_EVENT {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACL_FIBER_COND {
    _unused: [u8; 0],
}
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type mbstate_t = __darwin_mbstate_t;
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._r as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._file as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._close as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._read as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._write as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._extra as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __nitems: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __nitems: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::std::os::raw::c_char, arg2: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: size_t,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char, arg1: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: size_t,
        __format: *const ::std::os::raw::c_char,
        arg1: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut size_t,
        __stream: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: size_t,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(ts: *mut timespec, base: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wint_t = __darwin_wint_t;
pub type wctype_t = __darwin_wctype_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneEntry {
    pub __min: __darwin_rune_t,
    pub __max: __darwin_rune_t,
    pub __map: __darwin_rune_t,
    pub __types: *mut __uint32_t,
}
#[test]
fn bindgen_test_layout__RuneEntry() {
    assert_eq!(
        ::std::mem::size_of::<_RuneEntry>(),
        24usize,
        concat!("Size of: ", stringify!(_RuneEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneEntry>())).__min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneEntry>())).__max as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneEntry>())).__map as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneEntry>())).__types as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__types)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneRange {
    pub __nranges: ::std::os::raw::c_int,
    pub __ranges: *mut _RuneEntry,
}
#[test]
fn bindgen_test_layout__RuneRange() {
    assert_eq!(
        ::std::mem::size_of::<_RuneRange>(),
        16usize,
        concat!("Size of: ", stringify!(_RuneRange))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneRange>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneRange))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneRange>())).__nranges as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneRange),
            "::",
            stringify!(__nranges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneRange>())).__ranges as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneRange),
            "::",
            stringify!(__ranges)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneCharClass {
    pub __name: [::std::os::raw::c_char; 14usize],
    pub __mask: __uint32_t,
}
#[test]
fn bindgen_test_layout__RuneCharClass() {
    assert_eq!(
        ::std::mem::size_of::<_RuneCharClass>(),
        20usize,
        concat!("Size of: ", stringify!(_RuneCharClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneCharClass>(),
        4usize,
        concat!("Alignment of ", stringify!(_RuneCharClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneCharClass>())).__name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneCharClass),
            "::",
            stringify!(__name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneCharClass>())).__mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneCharClass),
            "::",
            stringify!(__mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneLocale {
    pub __magic: [::std::os::raw::c_char; 8usize],
    pub __encoding: [::std::os::raw::c_char; 32usize],
    pub __sgetrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: __darwin_size_t,
            arg3: *mut *const ::std::os::raw::c_char,
        ) -> __darwin_rune_t,
    >,
    pub __sputrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: __darwin_rune_t,
            arg2: *mut ::std::os::raw::c_char,
            arg3: __darwin_size_t,
            arg4: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub __invalid_rune: __darwin_rune_t,
    pub __runetype: [__uint32_t; 256usize],
    pub __maplower: [__darwin_rune_t; 256usize],
    pub __mapupper: [__darwin_rune_t; 256usize],
    pub __runetype_ext: _RuneRange,
    pub __maplower_ext: _RuneRange,
    pub __mapupper_ext: _RuneRange,
    pub __variable: *mut ::std::os::raw::c_void,
    pub __variable_len: ::std::os::raw::c_int,
    pub __ncharclasses: ::std::os::raw::c_int,
    pub __charclasses: *mut _RuneCharClass,
}
#[test]
fn bindgen_test_layout__RuneLocale() {
    assert_eq!(
        ::std::mem::size_of::<_RuneLocale>(),
        3208usize,
        concat!("Size of: ", stringify!(_RuneLocale))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneLocale>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneLocale))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__encoding as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__encoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__sgetrune as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__sgetrune)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__sputrune as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__sputrune)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__invalid_rune as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__invalid_rune)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__runetype as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__runetype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__maplower as *const _ as usize },
        1084usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__maplower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__mapupper as *const _ as usize },
        2108usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__mapupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__runetype_ext as *const _ as usize },
        3136usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__runetype_ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__maplower_ext as *const _ as usize },
        3152usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__maplower_ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__mapupper_ext as *const _ as usize },
        3168usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__mapupper_ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__variable as *const _ as usize },
        3184usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__variable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__variable_len as *const _ as usize },
        3192usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__variable_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__ncharclasses as *const _ as usize },
        3196usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__ncharclasses)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__charclasses as *const _ as usize },
        3200usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__charclasses)
        )
    );
}
extern "C" {
    pub static mut _DefaultRuneLocale: _RuneLocale;
}
extern "C" {
    pub static mut _CurrentRuneLocale: *mut _RuneLocale;
}
extern "C" {
    pub fn ___runetype(arg1: __darwin_ct_rune_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ___tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn ___toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn __maskrune(
        arg1: __darwin_ct_rune_t,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn __tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn wctype(arg1: *const ::std::os::raw::c_char) -> wctype_t;
}
extern "C" {
    pub fn btowc(arg1: ::std::os::raw::c_int) -> wint_t;
}
extern "C" {
    pub fn fgetwc(arg1: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn fgetws(arg1: *mut u32, arg2: ::std::os::raw::c_int, arg3: *mut FILE) -> *mut u32;
}
extern "C" {
    pub fn fputwc(arg1: u32, arg2: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn fputws(arg1: *const u32, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwide(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwprintf(arg1: *mut FILE, arg2: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwscanf(arg1: *mut FILE, arg2: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getwc(arg1: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn mbrlen(
        arg1: *const ::std::os::raw::c_char,
        arg2: size_t,
        arg3: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbrtowc(
        arg1: *mut u32,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbsinit(arg1: *const mbstate_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbsrtowcs(
        arg1: *mut u32,
        arg2: *mut *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn putwc(arg1: u32, arg2: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(arg1: u32) -> wint_t;
}
extern "C" {
    pub fn swprintf(arg1: *mut u32, arg2: size_t, arg3: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swscanf(arg1: *const u32, arg2: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(arg1: wint_t, arg2: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn vfwprintf(
        arg1: *mut FILE,
        arg2: *const u32,
        arg3: __darwin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswprintf(
        arg1: *mut u32,
        arg2: size_t,
        arg3: *const u32,
        arg4: __darwin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwprintf(arg1: *const u32, arg2: __darwin_va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcrtomb(arg1: *mut ::std::os::raw::c_char, arg2: u32, arg3: *mut mbstate_t) -> size_t;
}
extern "C" {
    pub fn wcscat(arg1: *mut u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcschr(arg1: *const u32, arg2: u32) -> *mut u32;
}
extern "C" {
    pub fn wcscmp(arg1: *const u32, arg2: *const u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscoll(arg1: *const u32, arg2: *const u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscpy(arg1: *mut u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcscspn(arg1: *const u32, arg2: *const u32) -> size_t;
}
extern "C" {
    pub fn wcsftime(arg1: *mut u32, arg2: size_t, arg3: *const u32, arg4: *const tm) -> size_t;
}
extern "C" {
    pub fn wcslen(arg1: *const u32) -> size_t;
}
extern "C" {
    pub fn wcsncat(arg1: *mut u32, arg2: *const u32, arg3: size_t) -> *mut u32;
}
extern "C" {
    pub fn wcsncmp(arg1: *const u32, arg2: *const u32, arg3: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncpy(arg1: *mut u32, arg2: *const u32, arg3: size_t) -> *mut u32;
}
extern "C" {
    pub fn wcspbrk(arg1: *const u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcsrchr(arg1: *const u32, arg2: u32) -> *mut u32;
}
extern "C" {
    pub fn wcsrtombs(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut *const u32,
        arg3: size_t,
        arg4: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcsspn(arg1: *const u32, arg2: *const u32) -> size_t;
}
extern "C" {
    pub fn wcsstr(arg1: *const u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcsxfrm(arg1: *mut u32, arg2: *const u32, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn wctob(arg1: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstod(arg1: *const u32, arg2: *mut *mut u32) -> f64;
}
extern "C" {
    pub fn wcstok(arg1: *mut u32, arg2: *const u32, arg3: *mut *mut u32) -> *mut u32;
}
extern "C" {
    pub fn wcstol(
        arg1: *const u32,
        arg2: *mut *mut u32,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoul(
        arg1: *const u32,
        arg2: *mut *mut u32,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wmemchr(arg1: *const u32, arg2: u32, arg3: size_t) -> *mut u32;
}
extern "C" {
    pub fn wmemcmp(arg1: *const u32, arg2: *const u32, arg3: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcpy(arg1: *mut u32, arg2: *const u32, arg3: size_t) -> *mut u32;
}
extern "C" {
    pub fn wmemmove(arg1: *mut u32, arg2: *const u32, arg3: size_t) -> *mut u32;
}
extern "C" {
    pub fn wmemset(arg1: *mut u32, arg2: u32, arg3: size_t) -> *mut u32;
}
extern "C" {
    pub fn wprintf(arg1: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wscanf(arg1: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcswidth(arg1: *const u32, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcwidth(arg1: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwscanf(
        arg1: *mut FILE,
        arg2: *const u32,
        arg3: __darwin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswscanf(
        arg1: *const u32,
        arg2: *const u32,
        arg3: __darwin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwscanf(arg1: *const u32, arg2: __darwin_va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstof(arg1: *const u32, arg2: *mut *mut u32) -> f32;
}
extern "C" {
    pub fn wcstold(arg1: *const u32, arg2: *mut *mut u32) -> f64;
}
extern "C" {
    pub fn wcstoll(
        arg1: *const u32,
        arg2: *mut *mut u32,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoull(
        arg1: *const u32,
        arg2: *mut *mut u32,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn mbsnrtowcs(
        arg1: *mut u32,
        arg2: *mut *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: size_t,
        arg5: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcpcpy(arg1: *mut u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcpncpy(arg1: *mut u32, arg2: *const u32, arg3: size_t) -> *mut u32;
}
extern "C" {
    pub fn wcsdup(arg1: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcscasecmp(arg1: *const u32, arg2: *const u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp(arg1: *const u32, arg2: *const u32, n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnlen(arg1: *const u32, arg2: size_t) -> size_t;
}
extern "C" {
    pub fn wcsnrtombs(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut *const u32,
        arg3: size_t,
        arg4: size_t,
        arg5: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn open_wmemstream(__bufp: *mut *mut u32, __sizep: *mut size_t) -> *mut FILE;
}
extern "C" {
    pub fn fgetwln(arg1: *mut FILE, arg2: *mut size_t) -> *mut u32;
}
extern "C" {
    pub fn wcslcat(arg1: *mut u32, arg2: *const u32, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn wcslcpy(arg1: *mut u32, arg2: *const u32, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> size_t;
}
extern "C" {
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> size_t;
}
extern "C" {
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__s1: *const ::std::os::raw::c_char, __n: size_t)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: size_t) -> size_t;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: size_t,
        __little: *const ::std::os::raw::c_void,
        __little_len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: size_t,
    );
}
extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: size_t,
    );
}
extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: size_t,
    );
}
extern "C" {
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ssize_t,
    );
}
extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsignal_r(
        __sig: ::std::os::raw::c_int,
        __strsignalbuf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: size_t);
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_exception_state>())).__exception as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__exception)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_exception_state>())).__fsr as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__fsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_exception_state>())).__far as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__far)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_exception_state64>())).__far as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__far)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_exception_state64>())).__esr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__esr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_exception_state64>())).__exception as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__exception)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state>(),
        68usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_arm_thread_state>())).__r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_arm_thread_state>())).__sp as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_arm_thread_state>())).__lr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_arm_thread_state>())).__pc as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_thread_state>())).__cpsr as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__cpsr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state64>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_arm_thread_state64>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_thread_state64>())).__fp as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__fp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_thread_state64>())).__lr as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_thread_state64>())).__sp as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_thread_state64>())).__pc as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_thread_state64>())).__cpsr as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__cpsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_thread_state64>())).__pad as *const _ as usize
        },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_vfp_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_vfp_state>(),
        260usize,
        concat!("Size of: ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_vfp_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_arm_vfp_state>())).__r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_arm_vfp_state>())).__fpscr as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__fpscr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state64>(),
        528usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_arm_neon_state64>())).__v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_neon_state64>())).__fpsr as *const _ as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_neon_state64>())).__fpcr as *const _ as usize
        },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_arm_neon_state>())).__v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_arm_neon_state>())).__fpsr as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_arm_neon_state>())).__fpcr as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___arm_pagein_state() {
    assert_eq!(
        ::std::mem::size_of::<__arm_pagein_state>(),
        4usize,
        concat!("Size of: ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_pagein_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__arm_pagein_state>())).__pagein_error as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_pagein_state),
            "::",
            stringify!(__pagein_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[test]
fn bindgen_test_layout___arm_legacy_debug_state() {
    assert_eq!(
        ::std::mem::size_of::<__arm_legacy_debug_state>(),
        256usize,
        concat!("Size of: ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_legacy_debug_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__arm_legacy_debug_state>())).__bvr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__arm_legacy_debug_state>())).__bcr as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__arm_legacy_debug_state>())).__wvr as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__arm_legacy_debug_state>())).__wcr as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state32>(),
        264usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state32>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_debug_state32>())).__bvr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_debug_state32>())).__bcr as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_debug_state32>())).__wvr as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_debug_state32>())).__wcr as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_debug_state32>())).__mdscr_el1 as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state64>(),
        520usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_debug_state64>())).__bvr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_debug_state64>())).__bcr as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_debug_state64>())).__wvr as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_debug_state64>())).__wcr as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_debug_state64>())).__mdscr_el1 as *const _ as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_arm_cpmu_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_arm_cpmu_state64>())).__ctrs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_cpmu_state64),
            "::",
            stringify!(__ctrs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        340usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__ss as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__fs as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        816usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__ss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__ns as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ns)
        )
    );
}
pub type mcontext_t = *mut __darwin_mcontext64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_onstack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_onstack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_sigmask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_stack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_link as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_mcsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_mcontext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify_function as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent>())).sigev_notify_attributes as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_pid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_status as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_value as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_band as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).__pad as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(__pad)
        )
    );
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction_u>())).__sa_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction_u>())).__sa_sigaction as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).__sigaction_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_tramp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_tramp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).__sigaction_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_onstack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_stime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_maxrss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_ixrss as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_idrss as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_isrss as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_minflt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_majflt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nswap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_inblock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_oublock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_msgsnd as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_msgrcv as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nsignals as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nvcsw as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nivcsw as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_default as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_maintenance as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_background as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_utility as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_legacy as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_user_initiated as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_user_interactive as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_billed_system_time as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_serviced_system_time as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v4>(),
        296usize,
        concat!("Size of: ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_default as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_maintenance as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_background as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_utility as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_legacy as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_user_initiated as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_user_interactive as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_billed_system_time as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_serviced_system_time as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_logical_writes as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_lifetime_max_phys_footprint as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_instructions as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_cycles as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_billed_energy as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_serviced_energy as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_interval_max_phys_footprint as *const _
                as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_runnable_time as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_runnable_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v5() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v5>(),
        304usize,
        concat!("Size of: ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v5>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_cpu_time_qos_default as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_cpu_time_qos_maintenance as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_cpu_time_qos_background as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_cpu_time_qos_utility as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_cpu_time_qos_legacy as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_cpu_time_qos_user_initiated as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_cpu_time_qos_user_interactive as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_billed_system_time as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_serviced_system_time as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_logical_writes as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_lifetime_max_phys_footprint as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_instructions as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_cycles as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_billed_energy as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_serviced_energy as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_interval_max_phys_footprint as *const _
                as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_runnable_time as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_flags as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_flags)
        )
    );
}
pub type rusage_info_current = rusage_info_v5;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<proc_rlimit_control_wakeupmon>())).wm_flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<proc_rlimit_control_wakeupmon>())).wm_rate as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_rate)
        )
    );
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_T as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_S as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
    );
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: size_t) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__count: size_t, __size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(arg1: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut u32, arg2: *const ::std::os::raw::c_char, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut u32,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const u32, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: size_t);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strtonum(
        __numstr: *const ::std::os::raw::c_char,
        __minval: ::std::os::raw::c_longlong,
        __maxval: ::std::os::raw::c_longlong,
        __errstrp: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __error() -> *mut ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
    pub __opaque: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        8usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).__opaque as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(__opaque)
        )
    );
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub const QOS_CLASS_USER_INTERACTIVE: ::std::os::raw::c_uint = 33;
pub const QOS_CLASS_USER_INITIATED: ::std::os::raw::c_uint = 25;
pub const QOS_CLASS_DEFAULT: ::std::os::raw::c_uint = 21;
pub const QOS_CLASS_UTILITY: ::std::os::raw::c_uint = 17;
pub const QOS_CLASS_BACKGROUND: ::std::os::raw::c_uint = 9;
pub const QOS_CLASS_UNSPECIFIED: ::std::os::raw::c_uint = 0;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub type qos_class_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn qos_class_self() -> qos_class_t;
}
extern "C" {
    pub fn qos_class_main() -> qos_class_t;
}
extern "C" {
    pub fn pthread_attr_set_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_get_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_set_qos_class_self_np(
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_get_qos_class_np(
        __pthread: pthread_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_override_s {
    _unused: [u8; 0],
}
pub type pthread_override_t = *mut pthread_override_s;
extern "C" {
    pub fn pthread_override_qos_class_start_np(
        __pthread: pthread_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> pthread_override_t;
}
extern "C" {
    pub fn pthread_override_qos_class_end_np(
        __override: pthread_override_t,
    ) -> ::std::os::raw::c_int;
}
pub type mach_port_t = __darwin_mach_port_t;
extern "C" {
    pub fn pthread_atfork(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
        arg3: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        arg1: *const pthread_attr_t,
        arg2: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        arg1: *const pthread_attr_t,
        arg2: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
        arg3: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        arg1: *const pthread_attr_t,
        arg2: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        arg1: *mut pthread_attr_t,
        arg2: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        arg1: *mut pthread_attr_t,
        arg2: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        arg1: *mut pthread_attr_t,
        arg2: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        arg1: *mut pthread_cond_t,
        arg2: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        arg1: *const pthread_condattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        arg1: *mut pthread_condattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_equal(arg1: pthread_t, arg2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_getconcurrency() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(arg1: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_join(
        arg1: pthread_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        arg1: *mut pthread_key_t,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(arg1: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        arg1: *const pthread_mutex_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        arg1: *mut pthread_mutex_t,
        arg2: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        arg1: *mut pthread_mutex_t,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpolicy_np(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpolicy_np(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        arg1: *mut pthread_once_t,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        arg1: *mut pthread_rwlock_t,
        arg2: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        arg1: *const pthread_rwlockattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        arg1: *mut pthread_rwlockattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_setcancelstate(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setconcurrency(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        arg1: pthread_t,
        arg2: ::std::os::raw::c_int,
        arg3: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setspecific(
        arg1: pthread_key_t,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
extern "C" {
    pub fn pthread_is_threaded_np() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_threadid_np(arg1: pthread_t, arg2: *mut __uint64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getname_np(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setname_np(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_main_np() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mach_thread_np(arg1: pthread_t) -> mach_port_t;
}
extern "C" {
    pub fn pthread_get_stacksize_np(arg1: pthread_t) -> size_t;
}
extern "C" {
    pub fn pthread_get_stackaddr_np(arg1: pthread_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_cond_signal_thread_np(
        arg1: *mut pthread_cond_t,
        arg2: pthread_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait_relative_np(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create_suspended_np(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_from_mach_thread_np(arg1: mach_port_t) -> pthread_t;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_yield_np();
}
extern "C" {
    pub fn pthread_jit_write_protect_np(enabled: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pthread_jit_write_protect_supported_np() -> ::std::os::raw::c_int;
}
pub type pthread_jit_write_callback_t = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn pthread_jit_write_with_callback_np(
        callback: pthread_jit_write_callback_t,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_jit_write_freeze_callbacks_np();
}
extern "C" {
    pub fn pthread_cpu_number_np(cpu_number_out: *mut size_t) -> ::std::os::raw::c_int;
}
pub type __libcpp_timespec_t = timespec;
extern "C" {
    pub fn __assert_rtn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACL_FIBER_SEM {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACL_CHANNEL {
    _unused: [u8; 0],
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[test]
fn __bindgen_test_layout_std___align_type_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___align_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___align_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___align_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___align_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___align_type_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___align_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___align_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___align_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___align_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___align_type_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___align_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___align_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___align_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___align_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___align_type_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___align_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___align_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___align_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___align_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___align_type_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___align_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___align_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___align_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___align_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___align_type_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___align_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___align_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___align_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___align_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___align_type_open0_long_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___align_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___align_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___align_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___align_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___align_type_open0_std___struct_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___align_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___align_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___align_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___align_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___align_type_open0_std___struct_double4_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___align_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___align_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___align_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___align_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___align_type_open0_ptr_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___align_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___align_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___align_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___align_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___type_list_open0_signed_char_std___type_list_open1_short_std___type_list_open2_int_std___type_list_open3_long_std___type_list_open4_long_long_std___type_list_open5___int128_t_std___nat_close5_close4_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___type_list>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___type_list)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___type_list>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___type_list)
        )
    );
}
pub type __int128_t = i128;
#[test]
fn __bindgen_test_layout_std___type_list_open0_unsigned_char_std___type_list_open1_unsigned_short_std___type_list_open2_unsigned_int_std___type_list_open3_unsigned_long_std___type_list_open4_unsigned_long_long_std___type_list_open5___uint128_t_std___nat_close5_close4_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___type_list>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___type_list)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___type_list>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___type_list)
        )
    );
}
pub type __uint128_t = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_3 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_4 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_5 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_6 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_7 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_long_std_nano_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_longlong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_longlong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_long_std_micro_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_longlong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_longlong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_long_std_milli_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_longlong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_longlong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_long_std_ratio_open1_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_longlong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_longlong>)
        )
    );
}
pub type rep = ::std::os::raw::c_longlong;
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_long_std_ratio_open1_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_longlong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_longlong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_time_point_open0_std_chrono_steady_clock_std_chrono_steady_clock_duration_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_time_point<std_chrono_steady_clock_duration>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_steady_clock_duration>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_time_point<std_chrono_steady_clock_duration>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_steady_clock_duration>)
        )
    );
}
pub type type_ = ::std::os::raw::c_uint;
#[test]
fn __bindgen_test_layout_std___cxx_atomic_impl_open0_bool__std___cxx_atomic_base_impl_open1_bool__close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___cxx_atomic_impl<std___cxx_atomic_base_impl>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___cxx_atomic_impl<std___cxx_atomic_base_impl>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___cxx_atomic_impl<std___cxx_atomic_base_impl>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___cxx_atomic_impl<std___cxx_atomic_base_impl>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___cxx_atomic_base_impl_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___cxx_atomic_base_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___cxx_atomic_base_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___cxx_atomic_base_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___cxx_atomic_base_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_9 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation_4(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation_5(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_void_std___builtin_new_allocator___builtin_new_deleter_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
